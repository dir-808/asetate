{% extends "base.html" %}

{% block title %}{{ release.display_artist }} - {{ release.display_title }} - Asetate{% endblock %}

{% block content %}
<div class="release-detail" data-release-id="{{ release.id }}">
    <a href="{{ url_for('releases.list_releases') }}" class="back-link">Back to collection</a>

    <header class="release-header">
        <div class="release-cover-large">
            {% if release.cover_art_url %}
            <img src="{{ release.cover_art_url }}" alt="{{ release.display_title }}">
            {% else %}
            <div class="cover-placeholder-large">
                <span>No Cover</span>
            </div>
            {% endif %}
        </div>
        <div class="release-info-large">
            <h1>{{ release.display_title }}</h1>
            <p class="release-artist-large">{{ release.display_artist }}</p>
            <div class="release-meta-large">
                {% if release.label %}<span>{{ release.label }}</span>{% endif %}
                {% if release.year %}<span>{{ release.year }}</span>{% endif %}
            </div>
            {% set avg_bpm = release.get_average_bpm() %}
            <div class="release-stats">
                <span>{{ stats.total }} tracks</span>
                <span class="stat-divider">•</span>
                <span class="text-success">{{ stats.playable }} playable</span>
                <span class="stat-divider">•</span>
                <span>{{ stats.has_bpm }} with BPM</span>
                {% if avg_bpm.value %}
                <span class="stat-divider">•</span>
                <span class="avg-bpm {% if avg_bpm.is_varied %}bpm-varied{% endif %}" title="Average BPM of playable tracks{% if avg_bpm.is_varied %} (BPM range varies significantly){% endif %}">
                    Avg: {{ avg_bpm.display }}
                </span>
                {% endif %}
            </div>
            <div class="release-actions">
                <a href="{{ release.discogs_uri }}" target="_blank" rel="noopener" class="btn btn-secondary btn-sm">
                    View on Discogs
                </a>
                {% if release.discogs_edit_url %}
                <a href="{{ release.discogs_edit_url }}" target="_blank" rel="noopener" class="btn btn-secondary btn-sm">
                    Suggest Edit
                </a>
                {% endif %}
                <button class="btn btn-primary btn-sm" id="btn-add-to-crate">Add to Crate</button>
                <button class="btn btn-secondary btn-sm" id="btn-add-to-cue" title="Add tracks to export cue">Add to Cue</button>
            </div>
            <div class="release-crates" id="release-crates">
                <!-- Crates will be loaded via JS -->
            </div>
        </div>
    </header>

    <!-- Release Notes Section -->
    <section class="release-notes-section">
        <div class="release-notes-header">
            <h3>Release Notes</h3>
            <button class="btn btn-secondary btn-sm" id="btn-edit-release-notes">
                {% if release.notes %}Edit{% else %}Add{% endif %}
            </button>
        </div>
        <div class="release-notes-content" id="release-notes-content">
            {% if release.notes %}
            <p>{{ release.notes }}</p>
            {% else %}
            <p class="text-muted">No notes yet. Click "Add" to add notes about this release.</p>
            {% endif %}
        </div>
    </section>

    <section class="tracks-section" data-visible-fields="{{ visible_fields | join(',') }}">
        <div class="tracks-header">
            <h2>Tracklist</h2>
            <div class="tracks-header-actions">
                <span class="save-indicator" id="save-indicator"></span>
                <button class="btn btn-secondary btn-sm" id="btn-column-settings" title="Column visibility">Columns</button>
            </div>
        </div>

        {% if tracks %}
        <div class="tracks-table-wrapper">
            <table class="tracks-table">
                <thead>
                    <tr>
                        <th class="col-pos {% if 'position' not in visible_fields %}hidden{% endif %}">Side</th>
                        <th class="col-title">Title</th>
                        <th class="col-duration {% if 'duration' not in visible_fields %}hidden{% endif %}">Length</th>
                        <th class="col-bpm {% if 'bpm' not in visible_fields %}hidden{% endif %}">BPM</th>
                        <th class="col-key {% if 'key' not in visible_fields %}hidden{% endif %}">Key</th>
                        <th class="col-energy {% if 'energy' not in visible_fields %}hidden{% endif %}">Energy</th>
                        <th class="col-tags {% if 'tags' not in visible_fields %}hidden{% endif %}">Tags</th>
                        <th class="col-playable">Playable</th>
                    </tr>
                </thead>
                <tbody>
                    {% for track in tracks %}
                    <tr class="track-row {% if track.is_playable %}track-playable{% endif %}"
                        data-track-id="{{ track.id }}">
                        <td class="col-pos {% if 'position' not in visible_fields %}hidden{% endif %}">{{ track.display_position }}</td>
                        <td class="col-title">
                            <span class="track-title">{{ track.title }}</span>
                            <span class="track-notes-btn {% if track.notes %}track-notes-indicator{% else %}track-notes-add{% endif %}"
                                  data-track-id="{{ track.id }}"
                                  data-track-title="{{ track.title }}"
                                  data-track-notes="{{ track.notes or '' }}"
                                  title="{{ track.notes if track.notes else 'Add notes' }}">
                                {% if track.notes %}Notes{% else %}+{% endif %}
                            </span>
                        </td>
                        <td class="col-duration {% if 'duration' not in visible_fields %}hidden{% endif %}">{{ track.display_duration }}</td>
                        <td class="col-bpm {% if 'bpm' not in visible_fields %}hidden{% endif %}">
                            <input
                                type="number"
                                class="track-input track-bpm"
                                value="{{ track.bpm or '' }}"
                                placeholder="—"
                                min="20"
                                max="300"
                                data-field="bpm"
                            >
                        </td>
                        <td class="col-key {% if 'key' not in visible_fields %}hidden{% endif %}">
                            <input
                                type="text"
                                class="track-input track-key"
                                value="{{ track.camelot or track.musical_key or '' }}"
                                placeholder="—"
                                data-field="camelot"
                                list="camelot-keys"
                            >
                        </td>
                        <td class="col-energy {% if 'energy' not in visible_fields %}hidden{% endif %}">
                            <div class="energy-slider-container">
                                <input
                                    type="range"
                                    class="track-energy-slider"
                                    value="{{ track.energy or 0 }}"
                                    min="0"
                                    max="5"
                                    data-field="energy"
                                >
                                <span class="energy-value">{{ track.energy if track.energy else '—' }}</span>
                            </div>
                        </td>
                        <td class="col-tags {% if 'tags' not in visible_fields %}hidden{% endif %}">
                            <div class="track-tags" data-track-id="{{ track.id }}">
                                {% for tag in track.tags %}
                                <span class="tag-badge" data-tag-id="{{ tag.id }}" style="--tag-color: {{ tag.color or '#E07A5F' }}">
                                    {{ tag.name }}
                                    <button class="tag-remove" title="Remove tag">&times;</button>
                                </span>
                                {% endfor %}
                                <button class="tag-add-btn" title="Add tag">+</button>
                            </div>
                        </td>
                        <td class="col-playable">
                            <label class="toggle">
                                <input
                                    type="checkbox"
                                    class="track-playable"
                                    {% if track.is_playable %}checked{% endif %}
                                    data-field="is_playable"
                                >
                                <span class="toggle-slider"></span>
                            </label>
                        </td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>

        <!-- Camelot key datalist for autocomplete -->
        <datalist id="camelot-keys">
            <option value="1A"><option value="1B">
            <option value="2A"><option value="2B">
            <option value="3A"><option value="3B">
            <option value="4A"><option value="4B">
            <option value="5A"><option value="5B">
            <option value="6A"><option value="6B">
            <option value="7A"><option value="7B">
            <option value="8A"><option value="8B">
            <option value="9A"><option value="9B">
            <option value="10A"><option value="10B">
            <option value="11A"><option value="11B">
            <option value="12A"><option value="12B">
        </datalist>

        {% else %}
        <p class="text-muted">No tracks found for this release.</p>
        {% endif %}
    </section>
</div>

<!-- Add to Crate Modal -->
<div class="modal" id="crate-modal">
    <div class="modal-backdrop"></div>
    <div class="modal-content">
        <div class="modal-header">
            <h2>Add to Crate</h2>
            <button class="modal-close" id="crate-modal-close">&times;</button>
        </div>
        <div class="crate-selector">
            <div id="crate-list" class="crate-select-list">
                <p class="text-muted">Loading crates...</p>
            </div>
            <div class="crate-selector-footer">
                <a href="{{ url_for('crates.list_crates') }}" class="text-secondary">Manage crates</a>
            </div>
        </div>
    </div>
</div>

<!-- Release Notes Modal -->
<div class="modal" id="release-notes-modal">
    <div class="modal-backdrop"></div>
    <div class="modal-content">
        <div class="modal-header">
            <h2>Release Notes</h2>
            <button class="modal-close" id="release-notes-modal-close">&times;</button>
        </div>
        <div class="form-group">
            <textarea id="release-notes-textarea" rows="6" placeholder="Add notes about this release...">{{ release.notes or '' }}</textarea>
        </div>
        <div class="modal-actions">
            <button type="button" class="btn btn-secondary" id="release-notes-cancel">Cancel</button>
            <button type="button" class="btn btn-primary" id="release-notes-save">Save</button>
        </div>
    </div>
</div>

<!-- Track Notes Modal -->
<div class="modal" id="track-notes-modal">
    <div class="modal-backdrop"></div>
    <div class="modal-content">
        <div class="modal-header">
            <h2>Track Notes</h2>
            <button class="modal-close" id="track-notes-modal-close">&times;</button>
        </div>
        <p class="track-notes-title" id="track-notes-title"></p>
        <div class="form-group">
            <textarea id="track-notes-textarea" rows="4" placeholder="Add notes about this track..."></textarea>
        </div>
        <div class="modal-actions">
            <button type="button" class="btn btn-secondary" id="track-notes-cancel">Cancel</button>
            <button type="button" class="btn btn-primary" id="track-notes-save">Save</button>
        </div>
    </div>
</div>

<!-- Column Settings Modal -->
<div class="modal" id="column-settings-modal">
    <div class="modal-backdrop"></div>
    <div class="modal-content modal-content-sm">
        <div class="modal-header">
            <h2>Visible Columns</h2>
            <button class="modal-close" id="column-settings-close">&times;</button>
        </div>
        <div class="column-settings-list" id="column-settings-list">
            <label class="column-setting">
                <input type="checkbox" data-field="position" checked>
                <span>Side</span>
            </label>
            <label class="column-setting">
                <input type="checkbox" data-field="title" checked disabled>
                <span>Title (always shown)</span>
            </label>
            <label class="column-setting">
                <input type="checkbox" data-field="duration" checked>
                <span>Length</span>
            </label>
            <label class="column-setting">
                <input type="checkbox" data-field="bpm" checked>
                <span>BPM</span>
            </label>
            <label class="column-setting">
                <input type="checkbox" data-field="key" checked>
                <span>Key</span>
            </label>
            <label class="column-setting">
                <input type="checkbox" data-field="energy" checked>
                <span>Energy</span>
            </label>
            <label class="column-setting">
                <input type="checkbox" data-field="tags" checked>
                <span>Tags</span>
            </label>
            <label class="column-setting">
                <input type="checkbox" data-field="playable" checked disabled>
                <span>Playable (always shown)</span>
            </label>
        </div>
        <div class="modal-actions">
            <button type="button" class="btn btn-secondary" id="column-settings-cancel">Cancel</button>
            <button type="button" class="btn btn-primary" id="column-settings-save">Save</button>
        </div>
    </div>
</div>

<style>
/* Column settings */
.tracks-header-actions {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
}

.column-settings-list {
    display: flex;
    flex-direction: column;
    gap: var(--space-sm);
}

.column-setting {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    padding: var(--space-xs) 0;
    cursor: pointer;
    font-size: 0.85rem;
}

.column-setting input[type="checkbox"] {
    width: auto;
    margin: 0;
}

.column-setting input:disabled + span {
    color: var(--text-muted);
}
/* Release Notes Section */
.release-notes-section {
    background: var(--bg-surface);
    border-radius: var(--radius-md);
    padding: var(--space-md) var(--space-lg);
    margin-bottom: var(--space-xl);
}

.release-notes-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--space-sm);
}

.release-notes-header h3 {
    margin: 0;
    font-size: 1rem;
}

.release-notes-content p {
    margin: 0;
    white-space: pre-wrap;
}

/* Notes modal textarea */
#release-notes-textarea,
#track-notes-textarea {
    width: 100%;
    padding: var(--space-sm);
    border: 1px solid var(--border);
    border-radius: var(--radius-sm);
    background: var(--bg-input);
    color: var(--text);
    font-family: inherit;
    font-size: 0.9rem;
    resize: vertical;
}

.track-notes-title {
    font-weight: 500;
    margin-bottom: var(--space-sm);
    color: var(--text-secondary);
}

/* Track notes indicator - clickable */
.track-notes-indicator {
    cursor: pointer;
    transition: background-color 0.15s;
}

.track-notes-indicator:hover {
    background-color: rgba(251, 191, 36, 0.3);
}

.track-notes-add {
    display: inline-block;
    padding: 2px 6px;
    font-size: 0.65rem;
    color: var(--text-muted);
    border: 1px dashed var(--border);
    border-radius: var(--radius-xs);
    cursor: pointer;
    opacity: 0;
    transition: opacity 0.15s;
}

.track-row:hover .track-notes-add {
    opacity: 1;
}

.track-notes-add:hover {
    border-color: var(--text-muted);
    color: var(--text-secondary);
}
</style>
{% endblock %}

{% block scripts %}
<script>
(function() {
    const releaseId = document.querySelector('.release-detail').dataset.releaseId;
    const saveIndicator = document.getElementById('save-indicator');
    let saveTimeout = null;

    function showSaving() {
        saveIndicator.textContent = 'Saving...';
        saveIndicator.className = 'save-indicator saving';
    }

    function showSaved() {
        saveIndicator.textContent = 'Saved';
        saveIndicator.className = 'save-indicator saved';
        clearTimeout(saveTimeout);
        saveTimeout = setTimeout(() => {
            saveIndicator.textContent = '';
            saveIndicator.className = 'save-indicator';
        }, 2000);
    }

    function showError(message) {
        saveIndicator.textContent = message || 'Error saving';
        saveIndicator.className = 'save-indicator error';
    }

    async function updateTrack(trackId, field, value) {
        showSaving();

        const data = {};
        data[field] = value;

        try {
            const response = await fetch(`/releases/${releaseId}/tracks/${trackId}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });

            const result = await response.json();

            if (response.ok) {
                showSaved();

                // Update row styling for playable status
                if (field === 'is_playable') {
                    const row = document.querySelector(`tr[data-track-id="${trackId}"]`);
                    if (value) {
                        row.classList.add('track-playable');
                    } else {
                        row.classList.remove('track-playable');
                    }
                }
            } else {
                showError(result.error);
            }
        } catch (err) {
            showError('Network error');
            console.error('Failed to update track:', err);
        }
    }

    // Handle input changes with debouncing
    let debounceTimers = {};

    function handleInputChange(e) {
        const input = e.target;
        const row = input.closest('tr');
        const trackId = row.dataset.trackId;
        const field = input.dataset.field;
        let value = input.value;

        // For checkboxes, use checked state
        if (input.type === 'checkbox') {
            value = input.checked;
            updateTrack(trackId, field, value);
            return;
        }

        // Debounce text/number inputs
        clearTimeout(debounceTimers[trackId + field]);
        debounceTimers[trackId + field] = setTimeout(() => {
            // Convert empty strings to null
            if (value === '') value = null;
            updateTrack(trackId, field, value);
        }, 500);
    }

    // Attach listeners to all track inputs
    document.querySelectorAll('.track-input, .track-playable').forEach(input => {
        if (input.type === 'checkbox') {
            input.addEventListener('change', handleInputChange);
        } else {
            input.addEventListener('input', handleInputChange);
            // Also save on blur for immediate feedback
            input.addEventListener('blur', (e) => {
                clearTimeout(debounceTimers[e.target.closest('tr').dataset.trackId + e.target.dataset.field]);
                handleInputChange(e);
            });
        }
    });

    // Energy slider handling
    document.querySelectorAll('.track-energy-slider').forEach(slider => {
        const valueDisplay = slider.nextElementSibling;

        slider.addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            valueDisplay.textContent = value === 0 ? '—' : value;
        });

        slider.addEventListener('change', (e) => {
            const row = slider.closest('tr');
            const trackId = row.dataset.trackId;
            const value = parseInt(e.target.value);
            updateTrack(trackId, 'energy', value === 0 ? null : value);
        });
    });

    // Keyboard navigation between cells
    document.querySelectorAll('.track-input').forEach(input => {
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === 'Tab') {
                // Let browser handle Tab normally
                if (e.key === 'Enter') {
                    e.preventDefault();
                    // Move to next row, same column
                    const row = input.closest('tr');
                    const nextRow = row.nextElementSibling;
                    if (nextRow) {
                        const nextInput = nextRow.querySelector(`.${input.classList[1]}`);
                        if (nextInput) nextInput.focus();
                    }
                }
            }
        });
    });

    // Crate management
    const crateModal = document.getElementById('crate-modal');
    const crateList = document.getElementById('crate-list');
    const releaseCratesContainer = document.getElementById('release-crates');
    let allCrates = [];
    let releaseCrateIds = [];

    async function loadCrates() {
        try {
            const [cratesRes, releaseRes] = await Promise.all([
                fetch('/crates/api/list'),
                fetch(`/crates/api/for-release/${releaseId}`)
            ]);
            const cratesData = await cratesRes.json();
            const releaseData = await releaseRes.json();

            allCrates = cratesData.crates;
            releaseCrateIds = releaseData.crate_ids;

            updateReleaseCratesDisplay();
        } catch (err) {
            console.error('Failed to load crates:', err);
        }
    }

    function updateReleaseCratesDisplay() {
        const inCrates = allCrates.filter(c => releaseCrateIds.includes(c.id));
        if (inCrates.length > 0) {
            releaseCratesContainer.innerHTML = inCrates.map(c => {
                const colorStyle = c.color_hex ? `background-color: ${c.color_hex}20; border-color: ${c.color_hex}40; color: ${c.color_hex}` : '';
                return `<a href="/crates/${c.id}" class="crate-badge" style="${colorStyle}">
                    <span class="crate-badge-icon">${c.icon}</span>
                    <span class="crate-badge-name">${c.name}</span>
                </a>`;
            }).join('');
        } else {
            releaseCratesContainer.innerHTML = '<span class="text-muted">Not in any crate</span>';
        }
    }

    function renderCrateList() {
        if (allCrates.length === 0) {
            crateList.innerHTML = '<p class="text-muted">No crates yet. <a href="/crates/">Create one</a></p>';
            return;
        }

        crateList.innerHTML = allCrates.map(c => {
            const isIn = releaseCrateIds.includes(c.id);
            const indent = '&nbsp;&nbsp;'.repeat(c.depth);
            return `
                <label class="crate-select-item">
                    <input type="checkbox" data-crate-id="${c.id}" ${isIn ? 'checked' : ''}>
                    <span>${indent}${c.name}</span>
                </label>
            `;
        }).join('');

        // Add event listeners
        crateList.querySelectorAll('input[type="checkbox"]').forEach(cb => {
            cb.addEventListener('change', async (e) => {
                const crateId = parseInt(cb.dataset.crateId);
                const isChecked = cb.checked;

                try {
                    if (isChecked) {
                        await fetch(`/crates/${crateId}/releases`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ release_id: parseInt(releaseId) })
                        });
                        releaseCrateIds.push(crateId);
                    } else {
                        await fetch(`/crates/${crateId}/releases/${releaseId}`, {
                            method: 'DELETE'
                        });
                        releaseCrateIds = releaseCrateIds.filter(id => id !== crateId);
                    }
                    updateReleaseCratesDisplay();
                } catch (err) {
                    cb.checked = !isChecked; // Revert
                    alert('Failed to update crate');
                }
            });
        });
    }

    document.getElementById('btn-add-to-crate').addEventListener('click', () => {
        renderCrateList();
        crateModal.classList.add('open');
    });

    document.getElementById('crate-modal-close').addEventListener('click', () => {
        crateModal.classList.remove('open');
    });

    crateModal.querySelector('.modal-backdrop').addEventListener('click', () => {
        crateModal.classList.remove('open');
    });

    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && crateModal.classList.contains('open')) {
            crateModal.classList.remove('open');
        }
    });

    // Load crates on page load
    loadCrates();

    // Tag management
    let allTags = [];

    async function loadAllTags() {
        try {
            const response = await fetch('/tags/');
            const data = await response.json();
            allTags = data.tags;
        } catch (err) {
            console.error('Failed to load tags:', err);
        }
    }

    function createTagElement(tag, trackId) {
        const span = document.createElement('span');
        span.className = 'tag-badge';
        span.dataset.tagId = tag.id;
        span.style.setProperty('--tag-color', tag.color || '#E07A5F');
        span.innerHTML = `${tag.name}<button class="tag-remove" title="Remove tag">&times;</button>`;

        span.querySelector('.tag-remove').addEventListener('click', async (e) => {
            e.stopPropagation();
            await removeTagFromTrack(trackId, tag.id);
            span.remove();
        });

        return span;
    }

    async function removeTagFromTrack(trackId, tagId) {
        try {
            await fetch(`/tags/track/${trackId}/${tagId}`, { method: 'DELETE' });
        } catch (err) {
            console.error('Failed to remove tag:', err);
        }
    }

    async function addTagToTrack(trackId, tagName) {
        try {
            const response = await fetch(`/tags/track/${trackId}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: tagName.trim().toLowerCase() })
            });
            const result = await response.json();
            if (response.ok) {
                return result.tag;
            } else {
                alert(result.error || 'Failed to add tag');
                return null;
            }
        } catch (err) {
            console.error('Failed to add tag:', err);
            return null;
        }
    }

    function showTagInput(container, trackId) {
        // Check if input already exists
        if (container.querySelector('.tag-input-wrapper')) return;

        const wrapper = document.createElement('div');
        wrapper.className = 'tag-input-wrapper';

        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'tag-input';
        input.placeholder = 'Add tag...';
        input.setAttribute('list', 'all-tags-list');

        wrapper.appendChild(input);
        container.insertBefore(wrapper, container.querySelector('.tag-add-btn'));

        input.focus();

        async function submitTag() {
            const value = input.value.trim();
            if (value) {
                const tag = await addTagToTrack(trackId, value);
                if (tag) {
                    const tagEl = createTagElement(tag, trackId);
                    container.insertBefore(tagEl, wrapper);
                }
            }
            wrapper.remove();
        }

        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                submitTag();
            } else if (e.key === 'Escape') {
                wrapper.remove();
            }
        });

        input.addEventListener('blur', () => {
            setTimeout(() => wrapper.remove(), 150);
        });
    }

    // Add tag button click handlers
    document.querySelectorAll('.tag-add-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const container = btn.closest('.track-tags');
            const trackId = container.dataset.trackId;
            showTagInput(container, trackId);
        });
    });

    // Remove tag button handlers for existing tags
    document.querySelectorAll('.tag-remove').forEach(btn => {
        btn.addEventListener('click', async (e) => {
            e.stopPropagation();
            const badge = btn.closest('.tag-badge');
            const container = btn.closest('.track-tags');
            const trackId = container.dataset.trackId;
            const tagId = badge.dataset.tagId;

            await removeTagFromTrack(trackId, tagId);
            badge.remove();
        });
    });

    // Load tags on page load
    loadAllTags();

    // Export Cue - Add all tracks from this release
    const addToCueBtn = document.getElementById('btn-add-to-cue');
    if (addToCueBtn) {
        addToCueBtn.addEventListener('click', () => {
            // Get all tracks from the table
            const trackRows = document.querySelectorAll('.track-row');
            const tracks = [];

            trackRows.forEach(row => {
                const trackId = parseInt(row.dataset.trackId);
                const titleEl = row.querySelector('.track-title');
                const title = titleEl ? titleEl.textContent : '';
                const position = row.querySelector('.col-pos')?.textContent || '';

                tracks.push({
                    track_id: trackId,
                    release_id: parseInt(releaseId),
                    artist: '{{ release.display_artist | e }}',
                    title: `${position} ${title}`.trim(),
                });
            });

            if (tracks.length === 0) {
                alert('No tracks to add');
                return;
            }

            // Add to localStorage cue
            let exportCue = JSON.parse(localStorage.getItem('asetate_export_cue') || '[]');

            let addedCount = 0;
            tracks.forEach(track => {
                if (!exportCue.some(q => q.track_id === track.track_id)) {
                    exportCue.push(track);
                    addedCount++;
                }
            });

            localStorage.setItem('asetate_export_cue', JSON.stringify(exportCue));

            // Show feedback
            if (addedCount > 0) {
                addToCueBtn.textContent = `Added ${addedCount} track${addedCount !== 1 ? 's' : ''}`;
                addToCueBtn.disabled = true;
                setTimeout(() => {
                    addToCueBtn.textContent = 'Add to Cue';
                    addToCueBtn.disabled = false;
                }, 2000);
            } else {
                addToCueBtn.textContent = 'Already in cue';
                setTimeout(() => {
                    addToCueBtn.textContent = 'Add to Cue';
                }, 1500);
            }
        });
    }

    // Release Notes Modal
    const releaseNotesModal = document.getElementById('release-notes-modal');
    const releaseNotesTextarea = document.getElementById('release-notes-textarea');
    const releaseNotesContent = document.getElementById('release-notes-content');

    function openReleaseNotesModal() {
        releaseNotesModal.classList.add('open');
        releaseNotesTextarea.focus();
    }

    function closeReleaseNotesModal() {
        releaseNotesModal.classList.remove('open');
    }

    document.getElementById('btn-edit-release-notes').addEventListener('click', openReleaseNotesModal);
    document.getElementById('release-notes-modal-close').addEventListener('click', closeReleaseNotesModal);
    document.getElementById('release-notes-cancel').addEventListener('click', closeReleaseNotesModal);
    releaseNotesModal.querySelector('.modal-backdrop').addEventListener('click', closeReleaseNotesModal);

    document.getElementById('release-notes-save').addEventListener('click', async () => {
        const notes = releaseNotesTextarea.value.trim();
        showSaving();

        try {
            const response = await fetch(`/releases/${releaseId}/notes`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ notes: notes || null })
            });

            if (response.ok) {
                showSaved();
                closeReleaseNotesModal();
                // Update the display
                if (notes) {
                    releaseNotesContent.innerHTML = `<p>${notes.replace(/\n/g, '<br>')}</p>`;
                    document.getElementById('btn-edit-release-notes').textContent = 'Edit';
                } else {
                    releaseNotesContent.innerHTML = '<p class="text-muted">No notes yet. Click "Add" to add notes about this release.</p>';
                    document.getElementById('btn-edit-release-notes').textContent = 'Add';
                }
            } else {
                showError('Failed to save notes');
            }
        } catch (err) {
            showError('Network error');
        }
    });

    // Track Notes Modal
    const trackNotesModal = document.getElementById('track-notes-modal');
    const trackNotesTextarea = document.getElementById('track-notes-textarea');
    const trackNotesTitle = document.getElementById('track-notes-title');
    let currentTrackNotesBtn = null;

    function openTrackNotesModal(btn) {
        currentTrackNotesBtn = btn;
        trackNotesTitle.textContent = btn.dataset.trackTitle;
        trackNotesTextarea.value = btn.dataset.trackNotes || '';
        trackNotesModal.classList.add('open');
        trackNotesTextarea.focus();
    }

    function closeTrackNotesModal() {
        trackNotesModal.classList.remove('open');
        currentTrackNotesBtn = null;
    }

    document.getElementById('track-notes-modal-close').addEventListener('click', closeTrackNotesModal);
    document.getElementById('track-notes-cancel').addEventListener('click', closeTrackNotesModal);
    trackNotesModal.querySelector('.modal-backdrop').addEventListener('click', closeTrackNotesModal);

    document.getElementById('track-notes-save').addEventListener('click', async () => {
        if (!currentTrackNotesBtn) return;

        const trackId = currentTrackNotesBtn.dataset.trackId;
        const notes = trackNotesTextarea.value.trim();
        showSaving();

        try {
            const response = await fetch(`/releases/${releaseId}/tracks/${trackId}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ notes: notes || null })
            });

            if (response.ok) {
                showSaved();
                closeTrackNotesModal();
                // Update the button display
                currentTrackNotesBtn.dataset.trackNotes = notes;
                currentTrackNotesBtn.title = notes || 'Add notes';
                if (notes) {
                    currentTrackNotesBtn.textContent = 'Notes';
                    currentTrackNotesBtn.classList.remove('track-notes-add');
                    currentTrackNotesBtn.classList.add('track-notes-indicator');
                } else {
                    currentTrackNotesBtn.textContent = '+';
                    currentTrackNotesBtn.classList.remove('track-notes-indicator');
                    currentTrackNotesBtn.classList.add('track-notes-add');
                }
            } else {
                showError('Failed to save notes');
            }
        } catch (err) {
            showError('Network error');
        }
    });

    // Track notes button click handlers
    document.querySelectorAll('.track-notes-btn').forEach(btn => {
        btn.addEventListener('click', () => openTrackNotesModal(btn));
    });

    // Close notes modals on Escape
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            if (releaseNotesModal.classList.contains('open')) closeReleaseNotesModal();
            if (trackNotesModal.classList.contains('open')) closeTrackNotesModal();
        }
    });

    // Column settings
    const columnSettingsModal = document.getElementById('column-settings-modal');
    const columnSettingsList = document.getElementById('column-settings-list');

    // Get current visible fields from data attribute
    const tracksSection = document.querySelector('.tracks-section');
    let visibleFields = tracksSection.dataset.visibleFields.split(',').filter(f => f);

    // Initialize checkboxes based on current visibility
    function initColumnSettings() {
        columnSettingsList.querySelectorAll('input[type="checkbox"]').forEach(cb => {
            const field = cb.dataset.field;
            if (!cb.disabled) {
                cb.checked = visibleFields.includes(field);
            }
        });
    }

    // Toggle column visibility
    function setColumnVisible(field, visible) {
        const colCells = document.querySelectorAll(`.col-${field}`);
        colCells.forEach(cell => {
            cell.classList.toggle('hidden', !visible);
        });
    }

    // Open column settings modal
    document.getElementById('btn-column-settings').addEventListener('click', () => {
        initColumnSettings();
        columnSettingsModal.classList.add('open');
    });

    // Close modal handlers
    function closeColumnSettingsModal() {
        columnSettingsModal.classList.remove('open');
    }

    document.getElementById('column-settings-close').addEventListener('click', closeColumnSettingsModal);
    document.getElementById('column-settings-cancel').addEventListener('click', closeColumnSettingsModal);
    columnSettingsModal.querySelector('.modal-backdrop').addEventListener('click', closeColumnSettingsModal);

    // Save column settings
    document.getElementById('column-settings-save').addEventListener('click', async () => {
        const newVisibleFields = [];
        columnSettingsList.querySelectorAll('input[type="checkbox"]').forEach(cb => {
            if (cb.checked) {
                newVisibleFields.push(cb.dataset.field);
            }
        });

        try {
            const response = await fetch('/releases/settings/visible-fields', {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ visible_fields: newVisibleFields })
            });

            if (response.ok) {
                const result = await response.json();
                visibleFields = result.visible_fields;

                // Update column visibility
                ['position', 'duration', 'bpm', 'key', 'energy', 'tags'].forEach(field => {
                    setColumnVisible(field, visibleFields.includes(field));
                });

                closeColumnSettingsModal();
                showSaved();
            } else {
                showError('Failed to save settings');
            }
        } catch (err) {
            showError('Network error');
        }
    });

    // Close on Escape
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && columnSettingsModal.classList.contains('open')) {
            closeColumnSettingsModal();
        }
    });
})();
</script>

<!-- Global datalist for tag autocomplete -->
<datalist id="all-tags-list"></datalist>
<script>
(function() {
    // Populate tag datalist after page load
    fetch('/tags/').then(r => r.json()).then(data => {
        const datalist = document.getElementById('all-tags-list');
        datalist.innerHTML = data.tags.map(t => `<option value="${t.name}">`).join('');
    });
})();
</script>
{% endblock %}
