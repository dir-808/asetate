{% extends "base.html" %}
{% from "_icons.html" import emoji_icon, crate_icon, sync_icon %}

{% block title %}{{ release.display_artist }} - {{ release.display_title }} - Asetate{% endblock %}

{% block content %}
<div class="release-detail" data-release-id="{{ release.id }}">
    <a href="{{ url_for('releases.list_releases') }}" class="back-link">Back to collection</a>

    <!-- Main Release Card - LCD styled, matches sidebar aesthetic -->
    <div class="detail-card">
        <!-- Top Row: Buttons + Cover + Crate + Info + Notes -->
        <div class="detail-header">
            <!-- Left Section: Buttons + Cover + Crate bar -->
            <div class="detail-left">
                <!-- Buttons + Cover row -->
                <div class="detail-media">
                    <!-- Action Buttons - vertical stack (5 buttons for 200px cover = 40px each = square) -->
                    <div class="detail-buttons">
                        <a href="{{ release.discogs_uri }}" target="_blank" rel="noopener"
                           class="detail-btn" title="View on Discogs">
                            {{ emoji_icon('link', size='sm') }}
                        </a>
                        {% if release.discogs_edit_url %}
                        <a href="{{ release.discogs_edit_url }}" target="_blank" rel="noopener"
                           class="detail-btn" title="Edit on Discogs">
                            {{ emoji_icon('edit', size='sm') }}
                        </a>
                        {% endif %}
                        <button class="detail-btn" id="btn-sync-release" title="Sync from Discogs">
                            <span class="activity-led"></span>
                            {{ sync_icon(size=14) }}
                        </button>
                        <a href="{{ url_for('export.export_page') }}" class="detail-btn" title="Print labels">
                            {{ emoji_icon('print', size='sm') }}
                        </a>
                        <button class="detail-btn" id="btn-hide-release" title="Hide from collection">
                            {{ emoji_icon('hide', size='sm') }}
                        </button>
                    </div>
                    <!-- Cover Art -->
                    <div class="detail-cover">
                        {% if release.cover_art_url %}
                        <img src="{{ release.cover_art_url }}" alt="{{ release.display_title }}">
                        {% else %}
                        <div class="cover-placeholder-detail">
                            <span>No Cover</span>
                        </div>
                        {% endif %}
                    </div>
                </div>
                <!-- Crate Bar - below buttons + cover -->
                <div class="detail-crate" id="detail-crate">
                    <!-- Empty state shown by default, JS will update to split button when crate assigned -->
                    <div id="detail-crate-content">
                        <button class="detail-crate-empty-btn" id="detail-crate-empty-btn">
                            <span class="detail-crate-text">+ Add to Crate</span>
                        </button>
                    </div>
                    <!-- Crate dropdown -->
                    <div class="detail-crate-dropdown" id="detail-crate-dropdown">
                        <div class="detail-crate-search">
                            <input type="text" id="detail-crate-search" placeholder="Search crates..." autocomplete="off">
                        </div>
                        <div class="detail-crate-list" id="detail-crate-list">
                            <!-- Crates loaded via JS -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Release Info - LCD styled -->
            <div class="detail-info">
                <h1>{{ release.display_title }}</h1>
                <p class="detail-artist">{{ release.display_artist }}</p>
                {% if release.catno %}
                <div class="detail-catno">{{ release.catno }}</div>
                {% endif %}
                <div class="detail-meta">
                    {% if release.label %}<span class="detail-label">{{ release.label }}</span>{% endif %}
                    {% if release.year %}<span class="detail-year">{{ release.year }}</span>{% endif %}
                </div>
                {% if release.format_details or release.country %}
                <div class="detail-meta detail-meta-secondary">
                    {% if release.format_details %}<span>{{ release.format_details }}</span>{% endif %}
                    {% if release.country %}<span>{{ release.country }}</span>{% endif %}
                </div>
                {% endif %}
                {% if release.display_genres or release.display_styles %}
                <div class="detail-meta detail-meta-secondary">
                    {% if release.display_genres %}<span>{{ release.display_genres }}</span>{% endif %}
                    {% if release.display_styles %}<span>{{ release.display_styles }}</span>{% endif %}
                </div>
                {% endif %}
                <div class="detail-divider"></div>
                {% set avg_bpm = release.get_average_bpm() %}
                <div class="detail-stats" id="release-stats">
                    <span id="stat-total">{{ stats.total }} tracks</span>
                    <span class="stat-divider">•</span>
                    <span class="text-success" id="stat-playable">{{ stats.playable }}▶</span>
                    {% if avg_bpm.value %}
                    <span class="stat-divider avg-bpm-divider">•</span>
                    <span class="avg-bpm {% if avg_bpm.is_varied %}bpm-varied{% endif %}" id="stat-avg-bpm" title="Average BPM of playable tracks{% if avg_bpm.is_varied %} (BPM range varies significantly){% endif %}">
                        {{ avg_bpm.display }} BPM
                    </span>
                    {% endif %}
                </div>
            </div>

            <!-- Notes - LCD styled textarea -->
            <div class="detail-notes">
                <textarea class="detail-notes-textarea" id="release-notes-inline" placeholder="Add notes...">{{ release.notes or '' }}</textarea>
            </div>
        </div>

        <!-- Track List Section -->
        <div class="detail-tracks-wrapper" id="detail-tracks-wrapper">
        <section class="detail-tracks-section" data-visible-fields="{{ visible_fields | join(',') }}">

        {% if tracks %}
        <div class="tracks-table-wrapper">
            <table class="tracks-table">
                <thead>
                    <tr>
                        <th class="col-playable">Playable</th>
                        <th class="col-pos {% if 'position' not in visible_fields %}hidden{% endif %}">Side</th>
                        <th class="col-title">Title</th>
                        <th class="col-duration {% if 'duration' not in visible_fields %}hidden{% endif %}">Length</th>
                        <th class="col-bpm {% if 'bpm' not in visible_fields %}hidden{% endif %}">BPM</th>
                        <th class="col-key {% if 'key' not in visible_fields %}hidden{% endif %}">Key</th>
                        <th class="col-energy {% if 'energy' not in visible_fields %}hidden{% endif %}">Energy</th>
                        <th class="col-tags {% if 'tags' not in visible_fields %}hidden{% endif %}">Tags</th>
                        <th class="col-settings"><button class="detail-columns-btn" id="btn-column-settings" title="Column visibility">Columns</button></th>
                    </tr>
                </thead>
                <tbody>
                    {% for track in tracks %}
                    <tr class="track-row {% if track.is_playable %}track-playable{% endif %}"
                        data-track-id="{{ track.id }}">
                        <td class="col-playable">
                            <label class="toggle">
                                <input
                                    type="checkbox"
                                    class="track-playable"
                                    {% if track.is_playable %}checked{% endif %}
                                    data-field="is_playable"
                                >
                                <span class="toggle-slider"></span>
                            </label>
                        </td>
                        <td class="col-pos {% if 'position' not in visible_fields %}hidden{% endif %}">{{ track.display_position }}</td>
                        <td class="col-title">
                            <span class="track-title">{{ track.title }}</span>
                            <span class="track-notes-btn {% if track.notes %}track-notes-indicator{% else %}track-notes-add{% endif %}"
                                  data-track-id="{{ track.id }}"
                                  data-track-title="{{ track.title }}"
                                  data-track-notes="{{ track.notes or '' }}"
                                  title="{{ track.notes if track.notes else 'Add notes' }}">
                                {% if track.notes %}Notes{% else %}+{% endif %}
                            </span>
                        </td>
                        <td class="col-duration {% if 'duration' not in visible_fields %}hidden{% endif %}">{{ track.display_duration }}</td>
                        <td class="col-bpm {% if 'bpm' not in visible_fields %}hidden{% endif %}">
                            <input
                                type="number"
                                class="track-input track-bpm"
                                value="{{ track.bpm or '' }}"
                                placeholder="—"
                                min="20"
                                max="300"
                                data-field="bpm"
                            >
                        </td>
                        <td class="col-key {% if 'key' not in visible_fields %}hidden{% endif %}">
                            <input
                                type="text"
                                class="track-input track-key"
                                value="{{ track.camelot or track.musical_key or '' }}"
                                placeholder="—"
                                data-field="camelot"
                                list="camelot-keys"
                            >
                        </td>
                        <td class="col-energy {% if 'energy' not in visible_fields %}hidden{% endif %}">
                            <div class="energy-bar" data-field="energy" data-value="{{ track.energy or 3 }}">
                                <div class="energy-segment" data-level="1"></div>
                                <div class="energy-segment" data-level="2"></div>
                                <div class="energy-segment" data-level="3"></div>
                                <div class="energy-segment" data-level="4"></div>
                                <div class="energy-segment" data-level="5"></div>
                            </div>
                        </td>
                        <td class="col-tags {% if 'tags' not in visible_fields %}hidden{% endif %}">
                            <div class="track-tags" data-track-id="{{ track.id }}">
                                {% for tag in track.tags %}
                                <span class="tag-badge" data-tag-id="{{ tag.id }}"{% if tag.color %} style="--tag-color: {{ tag.color }}"{% endif %}>
                                    {{ tag.name }}
                                    <button class="tag-remove" title="Remove tag">&times;</button>
                                </span>
                                {% endfor %}
                                <button class="tag-add-btn" title="Add tag">+</button>
                            </div>
                        </td>
                        <td class="col-settings"></td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>

        <!-- Camelot key datalist for autocomplete -->
        <datalist id="camelot-keys">
            <option value="1A"><option value="1B">
            <option value="2A"><option value="2B">
            <option value="3A"><option value="3B">
            <option value="4A"><option value="4B">
            <option value="5A"><option value="5B">
            <option value="6A"><option value="6B">
            <option value="7A"><option value="7B">
            <option value="8A"><option value="8B">
            <option value="9A"><option value="9B">
            <option value="10A"><option value="10B">
            <option value="11A"><option value="11B">
            <option value="12A"><option value="12B">
        </datalist>

        {% else %}
        <p class="text-muted p-md">No tracks found for this release.</p>
        {% endif %}
        </section>
        </div><!-- .detail-tracks-wrapper -->
    </div><!-- .detail-card -->
</div>

<!-- Track Notes Modal -->
<div class="modal" id="track-notes-modal">
    <div class="modal-backdrop"></div>
    <div class="modal-content">
        <div class="modal-header">
            <h2>Track Notes</h2>
            <button class="modal-close" id="track-notes-modal-close">&times;</button>
        </div>
        <p class="track-notes-title" id="track-notes-title"></p>
        <div class="form-group">
            <textarea id="track-notes-textarea" rows="4" placeholder="Add notes about this track..."></textarea>
        </div>
        <div class="modal-actions">
            <button type="button" class="btn btn-secondary" id="track-notes-cancel">Cancel</button>
            <button type="button" class="btn btn-primary" id="track-notes-save">Save</button>
        </div>
    </div>
</div>

<!-- Column Settings Modal -->
<div class="modal" id="column-settings-modal">
    <div class="modal-backdrop"></div>
    <div class="modal-content modal-content-sm">
        <div class="modal-header">
            <h2>Visible Columns</h2>
            <button class="modal-close" id="column-settings-close">&times;</button>
        </div>
        <div class="column-settings-list" id="column-settings-list">
            <label class="column-setting">
                <input type="checkbox" data-field="position" checked>
                <span>Side</span>
            </label>
            <label class="column-setting">
                <input type="checkbox" data-field="title" checked disabled>
                <span>Title (always shown)</span>
            </label>
            <label class="column-setting">
                <input type="checkbox" data-field="duration" checked>
                <span>Length</span>
            </label>
            <label class="column-setting">
                <input type="checkbox" data-field="bpm" checked>
                <span>BPM</span>
            </label>
            <label class="column-setting">
                <input type="checkbox" data-field="key" checked>
                <span>Key</span>
            </label>
            <label class="column-setting">
                <input type="checkbox" data-field="energy" checked>
                <span>Energy</span>
            </label>
            <label class="column-setting">
                <input type="checkbox" data-field="tags" checked>
                <span>Tags</span>
            </label>
            <label class="column-setting">
                <input type="checkbox" data-field="playable" checked disabled>
                <span>Playable (always shown)</span>
            </label>
        </div>
        <div class="modal-actions">
            <button type="button" class="btn btn-secondary" id="column-settings-cancel">Cancel</button>
            <button type="button" class="btn btn-primary" id="column-settings-save">Save</button>
        </div>
    </div>
</div>

<!-- NOTE: All detail page styles now in style.css RELEASE DETAIL PAGE section -->
{% endblock %}

{% block scripts %}
<script type="module">
import { renderCrateIcon, renderEmojiIcon, getIconName } from '/static/js/icons.js';

const releaseId = document.querySelector('.release-detail').dataset.releaseId;

    async function updateTrack(trackId, field, value) {
        const data = {};
        data[field] = value;

        try {
            const response = await fetch(`/releases/${releaseId}/tracks/${trackId}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });

            if (response.ok) {
                // Update row styling for playable status
                if (field === 'is_playable') {
                    const row = document.querySelector(`tr[data-track-id="${trackId}"]`);
                    if (value) {
                        row.classList.add('track-playable');
                    } else {
                        row.classList.remove('track-playable');
                    }
                    updateStats();
                }

                // Update stats when BPM changes
                if (field === 'bpm') {
                    updateStats();
                }
            }
        } catch (err) {
            console.error('Failed to update track:', err);
        }
    }

    // Handle input changes with debouncing
    let debounceTimers = {};

    function handleInputChange(e) {
        const input = e.target;
        const row = input.closest('tr');
        const trackId = row.dataset.trackId;
        const field = input.dataset.field;
        let value = input.value;

        // For checkboxes, use checked state
        if (input.type === 'checkbox') {
            value = input.checked;
            updateTrack(trackId, field, value);
            return;
        }

        // Debounce text/number inputs
        clearTimeout(debounceTimers[trackId + field]);
        debounceTimers[trackId + field] = setTimeout(() => {
            // Convert empty strings to null
            if (value === '') value = null;
            updateTrack(trackId, field, value);
        }, 500);
    }

    // Attach listeners to all track inputs
    document.querySelectorAll('.track-input, .track-playable').forEach(input => {
        if (input.type === 'checkbox') {
            input.addEventListener('change', handleInputChange);
        } else {
            input.addEventListener('input', handleInputChange);
            // Also save on blur for immediate feedback
            input.addEventListener('blur', (e) => {
                clearTimeout(debounceTimers[e.target.closest('tr').dataset.trackId + e.target.dataset.field]);
                handleInputChange(e);
            });
        }
    });

    // Energy bar click and drag handling - supports dragging outside the bar
    // Use global state to handle drag
    if (!window._detailEnergyDrag) {
        window._detailEnergyDrag = {
            isDragging: false,
            currentBar: null,
            currentTrackId: null,
            updateTrackFn: null
        };

        // Document-level listeners - only add once
        document.addEventListener('mousemove', (e) => {
            const state = window._detailEnergyDrag;
            if (state.isDragging && state.currentBar) {
                const rect = state.currentBar.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const segmentWidth = rect.width / 5;
                let level = Math.ceil(x / segmentWidth);
                level = Math.max(1, Math.min(5, level));
                state.currentBar.setAttribute('data-value', level);
            }
        });

        document.addEventListener('mouseup', (e) => {
            const state = window._detailEnergyDrag;
            if (state.isDragging && state.currentTrackId && state.currentBar && state.updateTrackFn) {
                const level = parseInt(state.currentBar.getAttribute('data-value'));
                state.updateTrackFn(state.currentTrackId, 'energy', level);
            }
            state.isDragging = false;
            state.currentBar = null;
            state.currentTrackId = null;
        });
    }

    // Update global state with current updateTrack function
    window._detailEnergyDrag.updateTrackFn = updateTrack;

    // Attach mousedown to energy bars
    document.querySelectorAll('.energy-bar').forEach(bar => {
        bar.addEventListener('mousedown', (e) => {
            const state = window._detailEnergyDrag;
            state.isDragging = true;
            state.currentBar = bar;
            const row = bar.closest('tr');
            state.currentTrackId = row.dataset.trackId;

            // Calculate and set initial level
            const rect = bar.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const segmentWidth = rect.width / 5;
            let level = Math.ceil(x / segmentWidth);
            level = Math.max(1, Math.min(5, level));
            bar.setAttribute('data-value', level);
            e.preventDefault();
        });
    });

    // Live stats update function
    function updateStats() {
        const rows = document.querySelectorAll('.track-row');
        let playableCount = 0;
        let bpmCount = 0;
        let totalBpm = 0;

        rows.forEach(row => {
            const isPlayable = row.classList.contains('track-playable');
            const bpmInput = row.querySelector('.track-bpm');
            const bpm = bpmInput ? parseInt(bpmInput.value) : null;

            if (isPlayable) {
                playableCount++;
                if (bpm && !isNaN(bpm)) {
                    totalBpm += bpm;
                    bpmCount++;
                }
            }

            if (bpm && !isNaN(bpm)) {
                // Count tracks with BPM regardless of playable status
            }
        });

        // Update stats display
        const statPlayable = document.getElementById('stat-playable');
        if (statPlayable) statPlayable.textContent = `${playableCount}▶`;

        // Update average BPM
        const statAvgBpm = document.getElementById('stat-avg-bpm');
        const avgBpmDivider = document.querySelector('.avg-bpm-divider');
        if (bpmCount > 0) {
            const avgBpm = Math.round(totalBpm / bpmCount);
            if (statAvgBpm) statAvgBpm.textContent = `${avgBpm} BPM`;
            if (avgBpmDivider) avgBpmDivider.style.display = '';
            if (statAvgBpm) statAvgBpm.style.display = '';
        } else {
            if (avgBpmDivider) avgBpmDivider.style.display = 'none';
            if (statAvgBpm) statAvgBpm.style.display = 'none';
        }
    }

    // Keyboard navigation between cells
    document.querySelectorAll('.track-input').forEach(input => {
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === 'Tab') {
                // Let browser handle Tab normally
                if (e.key === 'Enter') {
                    e.preventDefault();
                    // Move to next row, same column
                    const row = input.closest('tr');
                    const nextRow = row.nextElementSibling;
                    if (nextRow) {
                        const nextInput = nextRow.querySelector(`.${input.classList[1]}`);
                        if (nextInput) nextInput.focus();
                    }
                }
            }
        });
    });

    // Crate dropdown management (single crate per release)
    const crateBar = document.getElementById('detail-crate');
    const crateContent = document.getElementById('detail-crate-content');
    const crateDropdown = document.getElementById('detail-crate-dropdown');
    const crateDropdownList = document.getElementById('detail-crate-list');
    const crateSearchInput = document.getElementById('detail-crate-search');
    let allCrates = [];
    let currentCrateId = null;  // Single crate - null means not in any crate

    async function loadCrates() {
        try {
            const [cratesRes, releaseRes] = await Promise.all([
                fetch('/crates/api/list'),
                fetch(`/crates/api/for-release/${releaseId}`)
            ]);
            const cratesData = await cratesRes.json();
            const releaseData = await releaseRes.json();

            allCrates = cratesData.crates;
            // For single crate, take the first one (or null if empty)
            currentCrateId = releaseData.crate_ids.length > 0 ? releaseData.crate_ids[0] : null;

            updateCrateBarDisplay();
            updateCrateDropdown();
        } catch (err) {
            console.error('Failed to load crates:', err);
        }
    }

    // Calculate relative luminance of a hex color (WCAG formula)
    function getLuminance(hexColor) {
        // Remove # if present
        const hex = hexColor.replace('#', '');
        const r = parseInt(hex.substr(0, 2), 16) / 255;
        const g = parseInt(hex.substr(2, 2), 16) / 255;
        const b = parseInt(hex.substr(4, 2), 16) / 255;

        // Apply gamma correction (linearize)
        const rLin = r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
        const gLin = g <= 0.03928 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4);
        const bLin = b <= 0.03928 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4);

        // Calculate luminance
        return 0.2126 * rLin + 0.7152 * gLin + 0.0722 * bLin;
    }

    // Get appropriate text color based on background luminance
    function getContrastColor(hexColor) {
        const luminance = getLuminance(hexColor);
        // Use white text for dark backgrounds, dark text for light backgrounds
        // Threshold of 0.179 provides good contrast (WCAG AA standard)
        return luminance > 0.179 ? 'rgba(0, 0, 0, 0.85)' : 'rgba(255, 255, 255, 0.95)';
    }

    // Read all color calculation tokens from CSS custom properties
    const rootStyles = getComputedStyle(document.documentElement);

    // 3D button tokens
    const btn3dHighlight = parseFloat(rootStyles.getPropertyValue('--btn-3d-highlight')) || 0.15;
    const btn3dShadow = parseFloat(rootStyles.getPropertyValue('--btn-3d-shadow')) || 0.25;

    // Playable highlight tokens
    const playableAlphaFaint = parseFloat(rootStyles.getPropertyValue('--playable-alpha-faint')) || 0.03;
    const playableAlphaSubtle = parseFloat(rootStyles.getPropertyValue('--playable-alpha-subtle')) || 0.06;
    const playableAlphaBorder = parseFloat(rootStyles.getPropertyValue('--playable-alpha-border')) || 0.4;
    const playableDimAmount = parseFloat(rootStyles.getPropertyValue('--playable-dim-amount')) || 0.5;

    // Accent color tokens
    const accentBoostStrong = parseFloat(rootStyles.getPropertyValue('--accent-boost-strong')) || 0.25;
    const accentBoostLight = parseFloat(rootStyles.getPropertyValue('--accent-boost-light')) || 0.15;
    const accentMutedAlpha = parseFloat(rootStyles.getPropertyValue('--accent-muted-alpha')) || 0.35;

    // Blend color with white (for 3D light edges)
    // Uses --btn-3d-highlight token
    function lightenColor(hexColor, amount = btn3dHighlight) {
        const hex = hexColor.replace('#', '');
        const r = parseInt(hex.substr(0, 2), 16);
        const g = parseInt(hex.substr(2, 2), 16);
        const b = parseInt(hex.substr(4, 2), 16);

        // Blend toward white (255)
        const newR = Math.round(r + (255 - r) * amount);
        const newG = Math.round(g + (255 - g) * amount);
        const newB = Math.round(b + (255 - b) * amount);

        return `rgb(${newR}, ${newG}, ${newB})`;
    }

    // Blend color with black (for 3D dark edges)
    // Uses --btn-3d-shadow token
    function darkenColor(hexColor, amount = btn3dShadow) {
        const hex = hexColor.replace('#', '');
        const r = parseInt(hex.substr(0, 2), 16);
        const g = parseInt(hex.substr(2, 2), 16);
        const b = parseInt(hex.substr(4, 2), 16);

        // Blend toward black (0)
        const newR = Math.round(r * (1 - amount));
        const newG = Math.round(g * (1 - amount));
        const newB = Math.round(b * (1 - amount));

        return `rgb(${newR}, ${newG}, ${newB})`;
    }

    // Create rgba string from hex color with specified alpha
    function hexToRgba(hexColor, alpha) {
        const hex = hexColor.replace('#', '');
        const r = parseInt(hex.substr(0, 2), 16);
        const g = parseInt(hex.substr(2, 2), 16);
        const b = parseInt(hex.substr(4, 2), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    // Calculate accent color for Side column based on luminance
    // Dark crates get slightly more vibrant/saturated accents for readability
    // Uses --accent-boost-strong and --accent-boost-light tokens
    function getAccentColor(hexColor) {
        const luminance = getLuminance(hexColor);

        // For dark colors, boost brightness slightly to ensure visibility
        // For light colors, use as-is
        // Luminance thresholds are WCAG constants, not design tokens
        if (luminance < 0.15) {
            // Very dark - use --accent-boost-strong
            return lightenColor(hexColor, accentBoostStrong);
        } else if (luminance < 0.3) {
            // Dark - use --accent-boost-light
            return lightenColor(hexColor, accentBoostLight);
        } else {
            // Medium/light - use directly
            return hexColor;
        }
    }

    // Calculate muted color for non-playable Side column
    // Uses --accent-muted-alpha token
    function getMutedColor(hexColor) {
        return hexToRgba(hexColor, accentMutedAlpha);
    }

    // Set playable highlight colors on wrapper (or reset to defaults)
    // Uses tokens: --playable-alpha-faint, --playable-alpha-subtle, --playable-alpha-border, --playable-dim-amount
    function updatePlayableColors(wrapper, crateColor) {
        if (!wrapper) return;

        if (crateColor) {
            wrapper.style.setProperty('--playable-color', crateColor);
            wrapper.style.setProperty('--playable-dim', darkenColor(crateColor, playableDimAmount));
            wrapper.style.setProperty('--playable-bg-faint', hexToRgba(crateColor, playableAlphaFaint));
            wrapper.style.setProperty('--playable-bg-subtle', hexToRgba(crateColor, playableAlphaSubtle));
            wrapper.style.setProperty('--playable-border', hexToRgba(crateColor, playableAlphaBorder));

            // Side column colors - accent brighter for dark crates
            wrapper.style.setProperty('--playable-accent', getAccentColor(crateColor));
            wrapper.style.setProperty('--playable-muted', getMutedColor(crateColor));
        } else {
            // Reset to CSS defaults (primary/orange)
            wrapper.style.removeProperty('--playable-color');
            wrapper.style.removeProperty('--playable-dim');
            wrapper.style.removeProperty('--playable-bg-faint');
            wrapper.style.removeProperty('--playable-bg-subtle');
            wrapper.style.removeProperty('--playable-border');
            wrapper.style.removeProperty('--playable-accent');
            wrapper.style.removeProperty('--playable-muted');
        }
    }

    function updateCrateBarDisplay() {
        const currentCrate = currentCrateId ? allCrates.find(c => c.id === currentCrateId) : null;
        const tracksWrapper = document.getElementById('detail-tracks-wrapper');

        if (currentCrate) {
            // Update tracklist border with 3D effect matching crate color
            const bgColor = currentCrate.color_hex || '#3a3a3a';
            if (tracksWrapper) {
                // Apply 3D borders: light on top/left, dark on bottom/right
                // Uses --btn-3d-highlight and --btn-3d-shadow tokens
                tracksWrapper.style.borderTopColor = lightenColor(bgColor);
                tracksWrapper.style.borderLeftColor = lightenColor(bgColor);
                tracksWrapper.style.borderRightColor = darkenColor(bgColor);
                tracksWrapper.style.borderBottomColor = darkenColor(bgColor);

                // Update playable highlight colors to match crate
                updatePlayableColors(tracksWrapper, bgColor);
            }
            const textColor = getContrastColor(bgColor);
            const crateUrl = `/crates/${currentCrate.id}`;
            // Render crate icon (CSS will inherit color from parent, 'sm' matches text size)
            const iconHtml = renderCrateIcon(currentCrate, 'sm');
            crateContent.innerHTML = `
                <div class="detail-crate-split detail-crate-assigned" style="background-color: ${bgColor}">
                    <button class="detail-crate-dropdown-btn" style="color: ${textColor}" id="detail-crate-dropdown-btn" title="Change crate">
                        <span class="detail-crate-arrow">▼</span>
                    </button>
                    <a href="${crateUrl}" class="detail-crate-main" style="color: ${textColor}" title="Go to ${currentCrate.name}">
                        ${iconHtml}
                        <span class="detail-crate-name">${currentCrate.name}</span>
                    </a>
                </div>
            `;
            // Attach event listener to dropdown button
            document.getElementById('detail-crate-dropdown-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                toggleDropdown();
            });
        } else {
            // Reset tracklist border to default (CSS handles 3D via tokens)
            if (tracksWrapper) {
                tracksWrapper.style.borderTopColor = '';
                tracksWrapper.style.borderLeftColor = '';
                tracksWrapper.style.borderRightColor = '';
                tracksWrapper.style.borderBottomColor = '';

                // Reset playable highlight colors to default (primary/orange)
                updatePlayableColors(tracksWrapper, null);
            }
            // Show empty state - single button to open dropdown
            crateContent.innerHTML = `
                <button class="detail-crate-empty-btn" id="detail-crate-empty-btn">
                    <span class="detail-crate-text">+ Add to Crate</span>
                </button>
            `;
            // Attach event listener to empty button
            document.getElementById('detail-crate-empty-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                toggleDropdown();
            });
        }
    }

    function toggleDropdown() {
        // Check for 'block' not '!== none' because initial state is '' (CSS controlled)
        const isOpen = crateDropdown.style.display === 'block';
        if (isOpen) {
            closeDropdown();
        } else {
            openDropdown();
        }
    }

    function updateCrateDropdown(filterText = '') {
        const filter = filterText.toLowerCase();
        const filteredCrates = filter
            ? allCrates.filter(c => c.name.toLowerCase().includes(filter))
            : allCrates;

        if (allCrates.length === 0) {
            crateDropdownList.innerHTML = '<p class="text-muted p-sm">No crates yet. <a href="/crates/">Create one</a></p>';
            return;
        }

        if (filteredCrates.length === 0) {
            crateDropdownList.innerHTML = '<p class="text-muted p-sm">No matching crates</p>';
            return;
        }

        // Add "Remove from crate" option if currently in a crate
        let html = '';
        if (currentCrateId && !filter) {
            html += `<div class="detail-crate-item detail-crate-remove" data-crate-id="0">
                <span class="detail-crate-item-icon">✕</span>
                <span class="detail-crate-item-name">Remove from crate</span>
            </div>`;
        }

        html += filteredCrates.map(c => {
            const isSelected = c.id === currentCrateId;
            return `<div class="detail-crate-item ${isSelected ? 'selected' : ''}" data-crate-id="${c.id}">
                ${renderCrateIcon(c, 'base')}
                <span class="detail-crate-item-name">${c.name}</span>
            </div>`;
        }).join('');

        crateDropdownList.innerHTML = html;

        // Add click listeners
        crateDropdownList.querySelectorAll('.detail-crate-item').forEach(item => {
            item.addEventListener('click', async () => {
                const crateId = parseInt(item.dataset.crateId);
                await selectCrate(crateId === 0 ? null : crateId);
            });
        });
    }

    async function selectCrate(newCrateId) {
        // If same crate, do nothing
        if (newCrateId === currentCrateId) {
            closeDropdown();
            return;
        }

        try {
            // Remove from current crate if exists
            if (currentCrateId) {
                await fetch(`/crates/${currentCrateId}/releases/${releaseId}`, {
                    method: 'DELETE'
                });
            }

            // Add to new crate if specified
            if (newCrateId) {
                await fetch(`/crates/${newCrateId}/releases`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ release_id: parseInt(releaseId) })
                });
            }

            currentCrateId = newCrateId;
            updateCrateBarDisplay();
            closeDropdown();
        } catch (err) {
            console.error('Failed to update crate:', err);
        }
    }

    function openDropdown() {
        crateDropdown.style.display = 'block';
        crateSearchInput.value = '';
        crateSearchInput.focus();
        updateCrateDropdown();
    }

    function closeDropdown() {
        crateDropdown.style.display = 'none';
    }

    // Search filtering
    crateSearchInput.addEventListener('input', (e) => {
        updateCrateDropdown(e.target.value);
    });

    // Keyboard navigation
    crateSearchInput.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            closeDropdown();
        } else if (e.key === 'Enter') {
            const firstItem = crateDropdownList.querySelector('.detail-crate-item:not(.detail-crate-remove)');
            if (firstItem) {
                firstItem.click();
            }
        }
    });

    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
        if (!crateBar.contains(e.target)) {
            closeDropdown();
        }
    });

    // Attach initial click listener to the server-rendered empty button
    // (fixes first-click bug before loadCrates() replaces the button)
    const initialEmptyBtn = document.getElementById('detail-crate-empty-btn');
    if (initialEmptyBtn) {
        initialEmptyBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleDropdown();
        });
    }

    // Load crates on page load
    loadCrates();

    // Sync release button (icon only)
    const syncBtn = document.getElementById('btn-sync-release');
    if (syncBtn) {
        syncBtn.addEventListener('click', async () => {
            syncBtn.disabled = true;
            syncBtn.classList.add('is-loading');

            try {
                const response = await fetch(`/sync/release/${releaseId}`, {
                    method: 'POST'
                });

                if (response.ok) {
                    // Reload the page to show updated data
                    window.location.reload();
                } else {
                    syncBtn.classList.remove('is-loading');
                    syncBtn.classList.add('has-error');
                    setTimeout(() => {
                        syncBtn.classList.remove('has-error');
                        syncBtn.disabled = false;
                    }, 2000);
                }
            } catch (err) {
                syncBtn.classList.remove('is-loading');
                syncBtn.classList.add('has-error');
                setTimeout(() => {
                    syncBtn.classList.remove('has-error');
                    syncBtn.disabled = false;
                }, 2000);
            }
        });
    }

    // Tag management
    let allTags = [];

    async function loadAllTags() {
        try {
            const response = await fetch('/tags/');
            const data = await response.json();
            allTags = data.tags;
        } catch (err) {
            console.error('Failed to load tags:', err);
        }
    }

    function createTagElement(tag, trackId) {
        const span = document.createElement('span');
        span.className = 'tag-badge';
        span.dataset.tagId = tag.id;
        if (tag.color) {
            span.style.setProperty('--tag-color', tag.color);
        }
        span.innerHTML = `${tag.name}<button class="tag-remove" title="Remove tag">&times;</button>`;

        span.querySelector('.tag-remove').addEventListener('click', async (e) => {
            e.stopPropagation();
            await removeTagFromTrack(trackId, tag.id);
            span.remove();
        });

        return span;
    }

    async function removeTagFromTrack(trackId, tagId) {
        try {
            await fetch(`/tags/track/${trackId}/${tagId}`, { method: 'DELETE' });
        } catch (err) {
            console.error('Failed to remove tag:', err);
        }
    }

    async function addTagToTrack(trackId, tagName) {
        try {
            const response = await fetch(`/tags/track/${trackId}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: tagName.trim().toLowerCase() })
            });
            const result = await response.json();
            if (response.ok) {
                // Add new tag to allTags if it doesn't exist
                if (!allTags.some(t => t.id === result.tag.id)) {
                    allTags.push(result.tag);
                    // Update datalist
                    const datalist = document.getElementById('all-tags-list');
                    datalist.innerHTML = allTags.map(t => `<option value="${t.name}">`).join('');
                }
                return result.tag;
            } else if (response.status === 409) {
                // Tag already exists on track - silently ignore
                return null;
            } else {
                console.error(result.error || 'Failed to add tag');
                return null;
            }
        } catch (err) {
            console.error('Failed to add tag:', err);
            return null;
        }
    }

    function showTagInput(container, trackId) {
        // Check if input already exists
        if (container.querySelector('.tag-input-wrapper')) return;

        const wrapper = document.createElement('div');
        wrapper.className = 'tag-input-wrapper';

        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'tag-input';
        input.placeholder = 'Add tag...';
        input.setAttribute('list', 'all-tags-list');

        wrapper.appendChild(input);
        container.insertBefore(wrapper, container.querySelector('.tag-add-btn'));

        input.focus();

        async function submitTag() {
            const value = input.value.trim();
            if (value) {
                const tag = await addTagToTrack(trackId, value);
                if (tag) {
                    const tagEl = createTagElement(tag, trackId);
                    container.insertBefore(tagEl, wrapper);
                }
            }
            wrapper.remove();
        }

        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                submitTag();
            } else if (e.key === 'Escape') {
                wrapper.remove();
            }
        });

        // Handle datalist selection (click on dropdown option)
        input.addEventListener('change', () => {
            if (input.value.trim()) {
                submitTag();
            }
        });

        input.addEventListener('blur', () => {
            setTimeout(() => wrapper.remove(), 150);
        });
    }

    // Add tag button click handlers
    document.querySelectorAll('.tag-add-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const container = btn.closest('.track-tags');
            const trackId = container.dataset.trackId;
            showTagInput(container, trackId);
        });
    });

    // Remove tag button handlers for existing tags
    document.querySelectorAll('.tag-remove').forEach(btn => {
        btn.addEventListener('click', async (e) => {
            e.stopPropagation();
            const badge = btn.closest('.tag-badge');
            const container = btn.closest('.track-tags');
            const trackId = container.dataset.trackId;
            const tagId = badge.dataset.tagId;

            await removeTagFromTrack(trackId, tagId);
            badge.remove();
        });
    });

    // Load tags on page load
    loadAllTags();

    // Export Cue - Add all tracks from this release
    const addToCueBtn = document.getElementById('btn-add-to-cue');
    if (addToCueBtn) {
        addToCueBtn.addEventListener('click', () => {
            // Get all tracks from the table
            const trackRows = document.querySelectorAll('.track-row');
            const tracks = [];

            trackRows.forEach(row => {
                const trackId = parseInt(row.dataset.trackId);
                const titleEl = row.querySelector('.track-title');
                const title = titleEl ? titleEl.textContent : '';
                const position = row.querySelector('.col-pos')?.textContent || '';

                tracks.push({
                    track_id: trackId,
                    release_id: parseInt(releaseId),
                    artist: '{{ release.display_artist | e }}',
                    title: `${position} ${title}`.trim(),
                });
            });

            if (tracks.length === 0) {
                alert('No tracks to add');
                return;
            }

            // Add to localStorage cue
            let exportCue = JSON.parse(localStorage.getItem('asetate_export_cue') || '[]');

            let addedCount = 0;
            tracks.forEach(track => {
                if (!exportCue.some(q => q.track_id === track.track_id)) {
                    exportCue.push(track);
                    addedCount++;
                }
            });

            localStorage.setItem('asetate_export_cue', JSON.stringify(exportCue));

            // Show feedback
            if (addedCount > 0) {
                addToCueBtn.textContent = `Added ${addedCount} track${addedCount !== 1 ? 's' : ''}`;
                addToCueBtn.disabled = true;
                setTimeout(() => {
                    addToCueBtn.textContent = 'Add to Cue';
                    addToCueBtn.disabled = false;
                }, 2000);
            } else {
                addToCueBtn.textContent = 'Already in cue';
                setTimeout(() => {
                    addToCueBtn.textContent = 'Add to Cue';
                }, 1500);
            }
        });
    }

    // Inline Release Notes - auto-save with debounce
    const releaseNotesInline = document.getElementById('release-notes-inline');
    let notesDebounceTimer = null;

    async function saveReleaseNotes() {
        const notes = releaseNotesInline.value.trim();

        try {
            await fetch(`/releases/${releaseId}/notes`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ notes: notes || null })
            });
        } catch (err) {
            console.error('Failed to save notes:', err);
        }
    }

    releaseNotesInline.addEventListener('input', () => {
        clearTimeout(notesDebounceTimer);
        notesDebounceTimer = setTimeout(saveReleaseNotes, 800);
    });

    releaseNotesInline.addEventListener('blur', () => {
        clearTimeout(notesDebounceTimer);
        saveReleaseNotes();
    });

    // Track Notes Modal
    const trackNotesModal = document.getElementById('track-notes-modal');
    const trackNotesTextarea = document.getElementById('track-notes-textarea');
    const trackNotesTitle = document.getElementById('track-notes-title');
    let currentTrackNotesBtn = null;

    function openTrackNotesModal(btn) {
        currentTrackNotesBtn = btn;
        trackNotesTitle.textContent = btn.dataset.trackTitle;
        trackNotesTextarea.value = btn.dataset.trackNotes || '';
        trackNotesModal.classList.add('open');
        trackNotesTextarea.focus();
    }

    function closeTrackNotesModal() {
        trackNotesModal.classList.remove('open');
        currentTrackNotesBtn = null;
    }

    document.getElementById('track-notes-modal-close').addEventListener('click', closeTrackNotesModal);
    document.getElementById('track-notes-cancel').addEventListener('click', closeTrackNotesModal);
    trackNotesModal.querySelector('.modal-backdrop').addEventListener('click', closeTrackNotesModal);

    document.getElementById('track-notes-save').addEventListener('click', async () => {
        if (!currentTrackNotesBtn) return;

        const trackId = currentTrackNotesBtn.dataset.trackId;
        const notes = trackNotesTextarea.value.trim();

        try {
            const response = await fetch(`/releases/${releaseId}/tracks/${trackId}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ notes: notes || null })
            });

            if (response.ok) {
                closeTrackNotesModal();
                // Update the button display
                currentTrackNotesBtn.dataset.trackNotes = notes;
                currentTrackNotesBtn.title = notes || 'Add notes';
                if (notes) {
                    currentTrackNotesBtn.textContent = 'Notes';
                    currentTrackNotesBtn.classList.remove('track-notes-add');
                    currentTrackNotesBtn.classList.add('track-notes-indicator');
                } else {
                    currentTrackNotesBtn.textContent = '+';
                    currentTrackNotesBtn.classList.remove('track-notes-indicator');
                    currentTrackNotesBtn.classList.add('track-notes-add');
                }
            }
        } catch (err) {
            console.error('Failed to save notes:', err);
        }
    });

    // Track notes button click handlers
    document.querySelectorAll('.track-notes-btn').forEach(btn => {
        btn.addEventListener('click', () => openTrackNotesModal(btn));
    });

    // Close track notes modal on Escape
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            if (trackNotesModal.classList.contains('open')) closeTrackNotesModal();
        }
    });

    // Column settings
    const columnSettingsModal = document.getElementById('column-settings-modal');
    const columnSettingsList = document.getElementById('column-settings-list');

    // Get current visible fields from data attribute
    const tracksSection = document.querySelector('.detail-tracks-section');
    let visibleFields = tracksSection.dataset.visibleFields.split(',').filter(f => f);

    // Initialize checkboxes based on current visibility
    function initColumnSettings() {
        columnSettingsList.querySelectorAll('input[type="checkbox"]').forEach(cb => {
            const field = cb.dataset.field;
            if (!cb.disabled) {
                cb.checked = visibleFields.includes(field);
            }
        });
    }

    // Toggle column visibility
    function setColumnVisible(field, visible) {
        const colCells = document.querySelectorAll(`.col-${field}`);
        colCells.forEach(cell => {
            cell.classList.toggle('hidden', !visible);
        });
    }

    // Open column settings modal
    const columnSettingsBtn = document.getElementById('btn-column-settings');
    const tracksWrapperForPress = document.getElementById('detail-tracks-wrapper');

    columnSettingsBtn.addEventListener('click', () => {
        initColumnSettings();
        columnSettingsModal.classList.add('open');
    });

    // Press effect on wrapper when button is pressed
    columnSettingsBtn.addEventListener('mousedown', () => {
        if (tracksWrapperForPress) {
            tracksWrapperForPress.classList.add('is-pressed');
        }
    });

    document.addEventListener('mouseup', () => {
        if (tracksWrapperForPress) {
            tracksWrapperForPress.classList.remove('is-pressed');
        }
    });

    // Close modal handlers
    function closeColumnSettingsModal() {
        columnSettingsModal.classList.remove('open');
    }

    document.getElementById('column-settings-close').addEventListener('click', closeColumnSettingsModal);
    document.getElementById('column-settings-cancel').addEventListener('click', closeColumnSettingsModal);
    columnSettingsModal.querySelector('.modal-backdrop').addEventListener('click', closeColumnSettingsModal);

    // Save column settings
    document.getElementById('column-settings-save').addEventListener('click', async () => {
        const newVisibleFields = [];
        columnSettingsList.querySelectorAll('input[type="checkbox"]').forEach(cb => {
            if (cb.checked) {
                newVisibleFields.push(cb.dataset.field);
            }
        });

        try {
            const response = await fetch('/releases/settings/visible-fields', {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ visible_fields: newVisibleFields })
            });

            if (response.ok) {
                const result = await response.json();
                visibleFields = result.visible_fields;

                // Update column visibility
                ['position', 'duration', 'bpm', 'key', 'energy', 'tags'].forEach(field => {
                    setColumnVisible(field, visibleFields.includes(field));
                });

                closeColumnSettingsModal();
            }
        } catch (err) {
            console.error('Failed to save settings:', err);
        }
    });

// Close on Escape
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && columnSettingsModal.classList.contains('open')) {
        closeColumnSettingsModal();
    }
});
</script>

<!-- Global datalist for tag autocomplete -->
<datalist id="all-tags-list"></datalist>
<script>
(function() {
    // Populate tag datalist after page load
    fetch('/tags/').then(r => r.json()).then(data => {
        const datalist = document.getElementById('all-tags-list');
        datalist.innerHTML = data.tags.map(t => `<option value="${t.name}">`).join('');
    });
})();
</script>
{% endblock %}
