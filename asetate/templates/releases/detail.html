{% extends "base.html" %}

{% block title %}{{ release.display_artist }} - {{ release.display_title }} - Asetate{% endblock %}

{% block content %}
<div class="release-detail" data-release-id="{{ release.id }}">
    <a href="{{ url_for('releases.list_releases') }}" class="back-link">Back to collection</a>

    <header class="release-header">
        <div class="release-cover-large">
            {% if release.cover_art_url %}
            <img src="{{ release.cover_art_url }}" alt="{{ release.display_title }}">
            {% else %}
            <div class="cover-placeholder-large">
                <span>No Cover</span>
            </div>
            {% endif %}
        </div>
        <div class="release-info-large">
            <h1>{{ release.display_title }}</h1>
            <p class="release-artist-large">{{ release.display_artist }}</p>
            <div class="release-meta-large">
                {% if release.label %}<span>{{ release.label }}</span>{% endif %}
                {% if release.year %}<span>{{ release.year }}</span>{% endif %}
                {% if release.country %}<span>{{ release.country }}</span>{% endif %}
            </div>
            {% if release.format_details or release.display_genres or release.display_styles %}
            <div class="release-extra-info">
                {% if release.format_details %}
                <span class="release-format" title="Format">{{ release.format_details }}</span>
                {% endif %}
                {% if release.display_genres %}
                <span class="release-genre" title="Genre">{{ release.display_genres }}</span>
                {% endif %}
                {% if release.display_styles %}
                <span class="release-style" title="Style">{{ release.display_styles }}</span>
                {% endif %}
            </div>
            {% endif %}
            {% set avg_bpm = release.get_average_bpm() %}
            <div class="release-stats" id="release-stats">
                <span id="stat-total">{{ stats.total }} tracks</span>
                <span class="stat-divider">•</span>
                <span class="text-success" id="stat-playable">{{ stats.playable }} playable</span>
                <span class="stat-divider">•</span>
                <span id="stat-bpm">{{ stats.has_bpm }} with BPM</span>
                {% if avg_bpm.value %}
                <span class="stat-divider avg-bpm-divider">•</span>
                <span class="avg-bpm {% if avg_bpm.is_varied %}bpm-varied{% endif %}" id="stat-avg-bpm" title="Average BPM of playable tracks{% if avg_bpm.is_varied %} (BPM range varies significantly){% endif %}">
                    Avg: {{ avg_bpm.display }}
                </span>
                {% endif %}
            </div>
            <div class="release-actions">
                <div class="action-group discogs-actions">
                    <a href="{{ release.discogs_uri }}" target="_blank" rel="noopener" class="btn btn-secondary btn-sm">View</a>
                    {% if release.discogs_edit_url %}
                    <a href="{{ release.discogs_edit_url }}" target="_blank" rel="noopener" class="btn btn-secondary btn-sm">Edit</a>
                    {% endif %}
                    <button class="btn btn-secondary btn-sm" id="btn-sync-release" title="Sync from Discogs"><span class="activity-led"></span><span class="btn-text">Sync</span></button>
                </div>
                <div class="action-group asetate-actions">
                    <div class="crate-dropdown-wrapper">
                        <button class="btn btn-primary btn-sm" id="btn-add-to-crate">Crate ▾</button>
                        <div class="crate-dropdown" id="crate-dropdown" style="display: none;">
                            <div class="crate-dropdown-list" id="crate-dropdown-list">
                                <!-- Crates loaded via JS -->
                            </div>
                        </div>
                    </div>
                    <button class="btn btn-secondary btn-sm" id="btn-add-to-cue" title="Add tracks to print cue">Print cue</button>
                </div>
            </div>
            <div class="release-crates" id="release-crates">
                <!-- Crates will be loaded via JS -->
            </div>
        </div>
        <!-- Release Notes (right side) -->
        <textarea class="notes-textarea release-notes-simple" id="release-notes-inline" placeholder="Add notes about this release...">{{ release.notes or '' }}</textarea>
    </header>

    <section class="tracks-section" data-visible-fields="{{ visible_fields | join(',') }}">
        <div class="tracks-header">
            <h2>Tracklist</h2>
            <div class="tracks-header-actions">
                <button class="btn btn-secondary btn-sm" id="btn-column-settings" title="Column visibility">Columns</button>
            </div>
        </div>

        {% if tracks %}
        <div class="tracks-table-wrapper">
            <table class="tracks-table">
                <thead>
                    <tr>
                        <th class="col-pos {% if 'position' not in visible_fields %}hidden{% endif %}">Side</th>
                        <th class="col-title">Title</th>
                        <th class="col-duration {% if 'duration' not in visible_fields %}hidden{% endif %}">Length</th>
                        <th class="col-bpm {% if 'bpm' not in visible_fields %}hidden{% endif %}">BPM</th>
                        <th class="col-key {% if 'key' not in visible_fields %}hidden{% endif %}">Key</th>
                        <th class="col-energy {% if 'energy' not in visible_fields %}hidden{% endif %}">Energy</th>
                        <th class="col-tags {% if 'tags' not in visible_fields %}hidden{% endif %}">Tags</th>
                        <th class="col-playable">Playable</th>
                    </tr>
                </thead>
                <tbody>
                    {% for track in tracks %}
                    <tr class="track-row {% if track.is_playable %}track-playable{% endif %}"
                        data-track-id="{{ track.id }}">
                        <td class="col-pos {% if 'position' not in visible_fields %}hidden{% endif %}">{{ track.display_position }}</td>
                        <td class="col-title">
                            <span class="track-title">{{ track.title }}</span>
                            <span class="track-notes-btn {% if track.notes %}track-notes-indicator{% else %}track-notes-add{% endif %}"
                                  data-track-id="{{ track.id }}"
                                  data-track-title="{{ track.title }}"
                                  data-track-notes="{{ track.notes or '' }}"
                                  title="{{ track.notes if track.notes else 'Add notes' }}">
                                {% if track.notes %}Notes{% else %}+{% endif %}
                            </span>
                        </td>
                        <td class="col-duration {% if 'duration' not in visible_fields %}hidden{% endif %}">{{ track.display_duration }}</td>
                        <td class="col-bpm {% if 'bpm' not in visible_fields %}hidden{% endif %}">
                            <input
                                type="number"
                                class="track-input track-bpm"
                                value="{{ track.bpm or '' }}"
                                placeholder="—"
                                min="20"
                                max="300"
                                data-field="bpm"
                            >
                        </td>
                        <td class="col-key {% if 'key' not in visible_fields %}hidden{% endif %}">
                            <input
                                type="text"
                                class="track-input track-key"
                                value="{{ track.camelot or track.musical_key or '' }}"
                                placeholder="—"
                                data-field="camelot"
                                list="camelot-keys"
                            >
                        </td>
                        <td class="col-energy {% if 'energy' not in visible_fields %}hidden{% endif %}">
                            <div class="energy-bar" data-field="energy" data-value="{{ track.energy or 3 }}">
                                <div class="energy-segment" data-level="1"></div>
                                <div class="energy-segment" data-level="2"></div>
                                <div class="energy-segment" data-level="3"></div>
                                <div class="energy-segment" data-level="4"></div>
                                <div class="energy-segment" data-level="5"></div>
                            </div>
                        </td>
                        <td class="col-tags {% if 'tags' not in visible_fields %}hidden{% endif %}">
                            <div class="track-tags" data-track-id="{{ track.id }}">
                                {% for tag in track.tags %}
                                <span class="tag-badge" data-tag-id="{{ tag.id }}" style="--tag-color: {{ tag.color or '#E07A5F' }}">
                                    {{ tag.name }}
                                    <button class="tag-remove" title="Remove tag">&times;</button>
                                </span>
                                {% endfor %}
                                <button class="tag-add-btn" title="Add tag">+</button>
                            </div>
                        </td>
                        <td class="col-playable">
                            <label class="toggle">
                                <input
                                    type="checkbox"
                                    class="track-playable"
                                    {% if track.is_playable %}checked{% endif %}
                                    data-field="is_playable"
                                >
                                <span class="toggle-slider"></span>
                            </label>
                        </td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>

        <!-- Camelot key datalist for autocomplete -->
        <datalist id="camelot-keys">
            <option value="1A"><option value="1B">
            <option value="2A"><option value="2B">
            <option value="3A"><option value="3B">
            <option value="4A"><option value="4B">
            <option value="5A"><option value="5B">
            <option value="6A"><option value="6B">
            <option value="7A"><option value="7B">
            <option value="8A"><option value="8B">
            <option value="9A"><option value="9B">
            <option value="10A"><option value="10B">
            <option value="11A"><option value="11B">
            <option value="12A"><option value="12B">
        </datalist>

        {% else %}
        <p class="text-muted">No tracks found for this release.</p>
        {% endif %}
    </section>
</div>

<!-- Track Notes Modal -->
<div class="modal" id="track-notes-modal">
    <div class="modal-backdrop"></div>
    <div class="modal-content">
        <div class="modal-header">
            <h2>Track Notes</h2>
            <button class="modal-close" id="track-notes-modal-close">&times;</button>
        </div>
        <p class="track-notes-title" id="track-notes-title"></p>
        <div class="form-group">
            <textarea id="track-notes-textarea" rows="4" placeholder="Add notes about this track..."></textarea>
        </div>
        <div class="modal-actions">
            <button type="button" class="btn btn-secondary" id="track-notes-cancel">Cancel</button>
            <button type="button" class="btn btn-primary" id="track-notes-save">Save</button>
        </div>
    </div>
</div>

<!-- Column Settings Modal -->
<div class="modal" id="column-settings-modal">
    <div class="modal-backdrop"></div>
    <div class="modal-content modal-content-sm">
        <div class="modal-header">
            <h2>Visible Columns</h2>
            <button class="modal-close" id="column-settings-close">&times;</button>
        </div>
        <div class="column-settings-list" id="column-settings-list">
            <label class="column-setting">
                <input type="checkbox" data-field="position" checked>
                <span>Side</span>
            </label>
            <label class="column-setting">
                <input type="checkbox" data-field="title" checked disabled>
                <span>Title (always shown)</span>
            </label>
            <label class="column-setting">
                <input type="checkbox" data-field="duration" checked>
                <span>Length</span>
            </label>
            <label class="column-setting">
                <input type="checkbox" data-field="bpm" checked>
                <span>BPM</span>
            </label>
            <label class="column-setting">
                <input type="checkbox" data-field="key" checked>
                <span>Key</span>
            </label>
            <label class="column-setting">
                <input type="checkbox" data-field="energy" checked>
                <span>Energy</span>
            </label>
            <label class="column-setting">
                <input type="checkbox" data-field="tags" checked>
                <span>Tags</span>
            </label>
            <label class="column-setting">
                <input type="checkbox" data-field="playable" checked disabled>
                <span>Playable (always shown)</span>
            </label>
        </div>
        <div class="modal-actions">
            <button type="button" class="btn btn-secondary" id="column-settings-cancel">Cancel</button>
            <button type="button" class="btn btn-primary" id="column-settings-save">Save</button>
        </div>
    </div>
</div>

<!-- NOTE: All detail page styles now in style.css RELEASE DETAIL PAGE section -->
{% endblock %}

{% block scripts %}
<script>
(function() {
    const releaseId = document.querySelector('.release-detail').dataset.releaseId;

    async function updateTrack(trackId, field, value) {
        const data = {};
        data[field] = value;

        try {
            const response = await fetch(`/releases/${releaseId}/tracks/${trackId}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });

            if (response.ok) {
                // Update row styling for playable status
                if (field === 'is_playable') {
                    const row = document.querySelector(`tr[data-track-id="${trackId}"]`);
                    if (value) {
                        row.classList.add('track-playable');
                    } else {
                        row.classList.remove('track-playable');
                    }
                    updateStats();
                }

                // Update stats when BPM changes
                if (field === 'bpm') {
                    updateStats();
                }
            }
        } catch (err) {
            console.error('Failed to update track:', err);
        }
    }

    // Handle input changes with debouncing
    let debounceTimers = {};

    function handleInputChange(e) {
        const input = e.target;
        const row = input.closest('tr');
        const trackId = row.dataset.trackId;
        const field = input.dataset.field;
        let value = input.value;

        // For checkboxes, use checked state
        if (input.type === 'checkbox') {
            value = input.checked;
            updateTrack(trackId, field, value);
            return;
        }

        // Debounce text/number inputs
        clearTimeout(debounceTimers[trackId + field]);
        debounceTimers[trackId + field] = setTimeout(() => {
            // Convert empty strings to null
            if (value === '') value = null;
            updateTrack(trackId, field, value);
        }, 500);
    }

    // Attach listeners to all track inputs
    document.querySelectorAll('.track-input, .track-playable').forEach(input => {
        if (input.type === 'checkbox') {
            input.addEventListener('change', handleInputChange);
        } else {
            input.addEventListener('input', handleInputChange);
            // Also save on blur for immediate feedback
            input.addEventListener('blur', (e) => {
                clearTimeout(debounceTimers[e.target.closest('tr').dataset.trackId + e.target.dataset.field]);
                handleInputChange(e);
            });
        }
    });

    // Energy bar click and drag handling - supports dragging outside the bar
    // Use global state to handle drag
    if (!window._detailEnergyDrag) {
        window._detailEnergyDrag = {
            isDragging: false,
            currentBar: null,
            currentTrackId: null,
            updateTrackFn: null
        };

        // Document-level listeners - only add once
        document.addEventListener('mousemove', (e) => {
            const state = window._detailEnergyDrag;
            if (state.isDragging && state.currentBar) {
                const rect = state.currentBar.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const segmentWidth = rect.width / 5;
                let level = Math.ceil(x / segmentWidth);
                level = Math.max(1, Math.min(5, level));
                state.currentBar.setAttribute('data-value', level);
            }
        });

        document.addEventListener('mouseup', (e) => {
            const state = window._detailEnergyDrag;
            if (state.isDragging && state.currentTrackId && state.currentBar && state.updateTrackFn) {
                const level = parseInt(state.currentBar.getAttribute('data-value'));
                state.updateTrackFn(state.currentTrackId, 'energy', level);
            }
            state.isDragging = false;
            state.currentBar = null;
            state.currentTrackId = null;
        });
    }

    // Update global state with current updateTrack function
    window._detailEnergyDrag.updateTrackFn = updateTrack;

    // Attach mousedown to energy bars
    document.querySelectorAll('.energy-bar').forEach(bar => {
        bar.addEventListener('mousedown', (e) => {
            const state = window._detailEnergyDrag;
            state.isDragging = true;
            state.currentBar = bar;
            const row = bar.closest('tr');
            state.currentTrackId = row.dataset.trackId;

            // Calculate and set initial level
            const rect = bar.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const segmentWidth = rect.width / 5;
            let level = Math.ceil(x / segmentWidth);
            level = Math.max(1, Math.min(5, level));
            bar.setAttribute('data-value', level);
            e.preventDefault();
        });
    });

    // Live stats update function
    function updateStats() {
        const rows = document.querySelectorAll('.track-row');
        let playableCount = 0;
        let bpmCount = 0;
        let totalBpm = 0;

        rows.forEach(row => {
            const isPlayable = row.classList.contains('track-playable');
            const bpmInput = row.querySelector('.track-bpm');
            const bpm = bpmInput ? parseInt(bpmInput.value) : null;

            if (isPlayable) {
                playableCount++;
                if (bpm && !isNaN(bpm)) {
                    totalBpm += bpm;
                    bpmCount++;
                }
            }

            if (bpm && !isNaN(bpm)) {
                // Count tracks with BPM regardless of playable status
            }
        });

        // Update stats display
        const statPlayable = document.getElementById('stat-playable');
        if (statPlayable) statPlayable.textContent = `${playableCount} playable`;

        const bpmInputs = document.querySelectorAll('.track-bpm');
        let tracksWithBpm = 0;
        bpmInputs.forEach(input => {
            if (input.value && !isNaN(parseInt(input.value))) tracksWithBpm++;
        });
        const statBpm = document.getElementById('stat-bpm');
        if (statBpm) statBpm.textContent = `${tracksWithBpm} with BPM`;

        // Update average BPM
        const statAvgBpm = document.getElementById('stat-avg-bpm');
        const avgBpmDivider = document.querySelector('.avg-bpm-divider');
        if (bpmCount > 0) {
            const avgBpm = Math.round(totalBpm / bpmCount);
            if (statAvgBpm) statAvgBpm.textContent = `Avg: ${avgBpm}`;
            if (avgBpmDivider) avgBpmDivider.style.display = '';
            if (statAvgBpm) statAvgBpm.style.display = '';
        } else {
            if (avgBpmDivider) avgBpmDivider.style.display = 'none';
            if (statAvgBpm) statAvgBpm.style.display = 'none';
        }
    }

    // Keyboard navigation between cells
    document.querySelectorAll('.track-input').forEach(input => {
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === 'Tab') {
                // Let browser handle Tab normally
                if (e.key === 'Enter') {
                    e.preventDefault();
                    // Move to next row, same column
                    const row = input.closest('tr');
                    const nextRow = row.nextElementSibling;
                    if (nextRow) {
                        const nextInput = nextRow.querySelector(`.${input.classList[1]}`);
                        if (nextInput) nextInput.focus();
                    }
                }
            }
        });
    });

    // Crate dropdown management
    const crateBtn = document.getElementById('btn-add-to-crate');
    const crateDropdown = document.getElementById('crate-dropdown');
    const crateDropdownList = document.getElementById('crate-dropdown-list');
    const releaseCratesContainer = document.getElementById('release-crates');
    let allCrates = [];
    let releaseCrateIds = [];

    async function loadCrates() {
        try {
            const [cratesRes, releaseRes] = await Promise.all([
                fetch('/crates/api/list'),
                fetch(`/crates/api/for-release/${releaseId}`)
            ]);
            const cratesData = await cratesRes.json();
            const releaseData = await releaseRes.json();

            allCrates = cratesData.crates;
            releaseCrateIds = releaseData.crate_ids;

            updateReleaseCratesDisplay();
            updateCrateDropdown();
        } catch (err) {
            console.error('Failed to load crates:', err);
        }
    }

    // Helper to render crate icon HTML
    function renderCrateIcon(crate, scale = 1.2) {
        const colorStyle = crate.color_hex ? `color: ${crate.color_hex};` : '';
        let iconName = 'folder';
        if (crate.icon && crate.icon.startsWith('pixel:')) {
            iconName = crate.icon.slice(6);
        }
        return `<span class="px-icon px-icon--${iconName}" style="--px-scale: ${scale}; ${colorStyle}"></span>`;
    }

    function updateReleaseCratesDisplay() {
        const inCrates = allCrates.filter(c => releaseCrateIds.includes(c.id));
        if (inCrates.length > 0) {
            releaseCratesContainer.innerHTML = inCrates.map(c => {
                const bgStyle = c.color_hex ? `background-color: ${c.color_hex}20; border-color: ${c.color_hex}40;` : '';
                return `<a href="/crates/${c.id}" class="crate-badge" style="${bgStyle}">
                    ${renderCrateIcon(c)}
                    <span class="crate-badge-name">${c.name}</span>
                </a>`;
            }).join('');
        } else {
            releaseCratesContainer.innerHTML = '<span class="text-muted">Not in any crate</span>';
        }
    }

    function updateCrateDropdown() {
        if (allCrates.length === 0) {
            crateDropdownList.innerHTML = '<p class="text-muted" style="padding: var(--space-sm);">No crates yet. <a href="/crates/">Create one</a></p>';
            return;
        }

        crateDropdownList.innerHTML = allCrates.map(c => {
            const isSelected = releaseCrateIds.includes(c.id);
            return `<label class="crate-dropdown-item ${isSelected ? 'selected' : ''}" data-crate-id="${c.id}">
                <input type="checkbox" ${isSelected ? 'checked' : ''}>
                ${renderCrateIcon(c, 1.2)}
                <span class="crate-dropdown-item-name">${c.name}</span>
            </label>`;
        }).join('');

        // Add event listeners
        crateDropdownList.querySelectorAll('.crate-dropdown-item input[type="checkbox"]').forEach(cb => {
            cb.addEventListener('change', async (e) => {
                const item = cb.closest('.crate-dropdown-item');
                const crateId = parseInt(item.dataset.crateId);

                if (cb.checked) {
                    try {
                        const res = await fetch(`/crates/${crateId}/releases`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ release_id: parseInt(releaseId) })
                        });
                        if (res.ok) {
                            releaseCrateIds.push(crateId);
                            item.classList.add('selected');
                        } else {
                            cb.checked = false;
                        }
                    } catch (err) {
                        cb.checked = false;
                    }
                } else {
                    try {
                        const res = await fetch(`/crates/${crateId}/releases/${releaseId}`, {
                            method: 'DELETE'
                        });
                        if (res.ok) {
                            releaseCrateIds = releaseCrateIds.filter(id => id !== crateId);
                            item.classList.remove('selected');
                        } else {
                            cb.checked = true;
                        }
                    } catch (err) {
                        cb.checked = true;
                    }
                }
                updateReleaseCratesDisplay();
            });
        });
    }

    // Toggle dropdown
    crateBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const isOpen = crateDropdown.style.display !== 'none';
        crateDropdown.style.display = isOpen ? 'none' : 'block';
    });

    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
        if (!crateDropdown.contains(e.target) && e.target !== crateBtn) {
            crateDropdown.style.display = 'none';
        }
    });

    // Load crates on page load
    loadCrates();

    // Sync release button
    const syncBtn = document.getElementById('btn-sync-release');
    if (syncBtn) {
        const syncBtnText = syncBtn.querySelector('.btn-text');
        syncBtn.addEventListener('click', async () => {
            syncBtn.disabled = true;
            syncBtn.classList.add('is-loading');
            syncBtnText.textContent = 'Syncing...';

            try {
                const response = await fetch(`/sync/release/${releaseId}`, {
                    method: 'POST'
                });

                if (response.ok) {
                    // Reload the page to show updated data
                    window.location.reload();
                } else {
                    syncBtn.classList.remove('is-loading');
                    syncBtnText.textContent = 'Error';
                    setTimeout(() => {
                        syncBtnText.textContent = 'Sync';
                        syncBtn.disabled = false;
                    }, 2000);
                }
            } catch (err) {
                syncBtn.classList.remove('is-loading');
                syncBtnText.textContent = 'Error';
                setTimeout(() => {
                    syncBtnText.textContent = 'Sync';
                    syncBtn.disabled = false;
                }, 2000);
            }
        });
    }

    // Tag management
    let allTags = [];

    async function loadAllTags() {
        try {
            const response = await fetch('/tags/');
            const data = await response.json();
            allTags = data.tags;
        } catch (err) {
            console.error('Failed to load tags:', err);
        }
    }

    function createTagElement(tag, trackId) {
        const span = document.createElement('span');
        span.className = 'tag-badge';
        span.dataset.tagId = tag.id;
        span.style.setProperty('--tag-color', tag.color || '#E07A5F');
        span.innerHTML = `${tag.name}<button class="tag-remove" title="Remove tag">&times;</button>`;

        span.querySelector('.tag-remove').addEventListener('click', async (e) => {
            e.stopPropagation();
            await removeTagFromTrack(trackId, tag.id);
            span.remove();
        });

        return span;
    }

    async function removeTagFromTrack(trackId, tagId) {
        try {
            await fetch(`/tags/track/${trackId}/${tagId}`, { method: 'DELETE' });
        } catch (err) {
            console.error('Failed to remove tag:', err);
        }
    }

    async function addTagToTrack(trackId, tagName) {
        try {
            const response = await fetch(`/tags/track/${trackId}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: tagName.trim().toLowerCase() })
            });
            const result = await response.json();
            if (response.ok) {
                // Add new tag to allTags if it doesn't exist
                if (!allTags.some(t => t.id === result.tag.id)) {
                    allTags.push(result.tag);
                    // Update datalist
                    const datalist = document.getElementById('all-tags-list');
                    datalist.innerHTML = allTags.map(t => `<option value="${t.name}">`).join('');
                }
                return result.tag;
            } else if (response.status === 409) {
                // Tag already exists on track - silently ignore
                return null;
            } else {
                console.error(result.error || 'Failed to add tag');
                return null;
            }
        } catch (err) {
            console.error('Failed to add tag:', err);
            return null;
        }
    }

    function showTagInput(container, trackId) {
        // Check if input already exists
        if (container.querySelector('.tag-input-wrapper')) return;

        const wrapper = document.createElement('div');
        wrapper.className = 'tag-input-wrapper';

        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'tag-input';
        input.placeholder = 'Add tag...';
        input.setAttribute('list', 'all-tags-list');

        wrapper.appendChild(input);
        container.insertBefore(wrapper, container.querySelector('.tag-add-btn'));

        input.focus();

        async function submitTag() {
            const value = input.value.trim();
            if (value) {
                const tag = await addTagToTrack(trackId, value);
                if (tag) {
                    const tagEl = createTagElement(tag, trackId);
                    container.insertBefore(tagEl, wrapper);
                }
            }
            wrapper.remove();
        }

        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                submitTag();
            } else if (e.key === 'Escape') {
                wrapper.remove();
            }
        });

        // Handle datalist selection (click on dropdown option)
        input.addEventListener('change', () => {
            if (input.value.trim()) {
                submitTag();
            }
        });

        input.addEventListener('blur', () => {
            setTimeout(() => wrapper.remove(), 150);
        });
    }

    // Add tag button click handlers
    document.querySelectorAll('.tag-add-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const container = btn.closest('.track-tags');
            const trackId = container.dataset.trackId;
            showTagInput(container, trackId);
        });
    });

    // Remove tag button handlers for existing tags
    document.querySelectorAll('.tag-remove').forEach(btn => {
        btn.addEventListener('click', async (e) => {
            e.stopPropagation();
            const badge = btn.closest('.tag-badge');
            const container = btn.closest('.track-tags');
            const trackId = container.dataset.trackId;
            const tagId = badge.dataset.tagId;

            await removeTagFromTrack(trackId, tagId);
            badge.remove();
        });
    });

    // Load tags on page load
    loadAllTags();

    // Export Cue - Add all tracks from this release
    const addToCueBtn = document.getElementById('btn-add-to-cue');
    if (addToCueBtn) {
        addToCueBtn.addEventListener('click', () => {
            // Get all tracks from the table
            const trackRows = document.querySelectorAll('.track-row');
            const tracks = [];

            trackRows.forEach(row => {
                const trackId = parseInt(row.dataset.trackId);
                const titleEl = row.querySelector('.track-title');
                const title = titleEl ? titleEl.textContent : '';
                const position = row.querySelector('.col-pos')?.textContent || '';

                tracks.push({
                    track_id: trackId,
                    release_id: parseInt(releaseId),
                    artist: '{{ release.display_artist | e }}',
                    title: `${position} ${title}`.trim(),
                });
            });

            if (tracks.length === 0) {
                alert('No tracks to add');
                return;
            }

            // Add to localStorage cue
            let exportCue = JSON.parse(localStorage.getItem('asetate_export_cue') || '[]');

            let addedCount = 0;
            tracks.forEach(track => {
                if (!exportCue.some(q => q.track_id === track.track_id)) {
                    exportCue.push(track);
                    addedCount++;
                }
            });

            localStorage.setItem('asetate_export_cue', JSON.stringify(exportCue));

            // Show feedback
            if (addedCount > 0) {
                addToCueBtn.textContent = `Added ${addedCount} track${addedCount !== 1 ? 's' : ''}`;
                addToCueBtn.disabled = true;
                setTimeout(() => {
                    addToCueBtn.textContent = 'Add to Cue';
                    addToCueBtn.disabled = false;
                }, 2000);
            } else {
                addToCueBtn.textContent = 'Already in cue';
                setTimeout(() => {
                    addToCueBtn.textContent = 'Add to Cue';
                }, 1500);
            }
        });
    }

    // Inline Release Notes - auto-save with debounce
    const releaseNotesInline = document.getElementById('release-notes-inline');
    let notesDebounceTimer = null;

    async function saveReleaseNotes() {
        const notes = releaseNotesInline.value.trim();

        try {
            await fetch(`/releases/${releaseId}/notes`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ notes: notes || null })
            });
        } catch (err) {
            console.error('Failed to save notes:', err);
        }
    }

    releaseNotesInline.addEventListener('input', () => {
        clearTimeout(notesDebounceTimer);
        notesDebounceTimer = setTimeout(saveReleaseNotes, 800);
    });

    releaseNotesInline.addEventListener('blur', () => {
        clearTimeout(notesDebounceTimer);
        saveReleaseNotes();
    });

    // Track Notes Modal
    const trackNotesModal = document.getElementById('track-notes-modal');
    const trackNotesTextarea = document.getElementById('track-notes-textarea');
    const trackNotesTitle = document.getElementById('track-notes-title');
    let currentTrackNotesBtn = null;

    function openTrackNotesModal(btn) {
        currentTrackNotesBtn = btn;
        trackNotesTitle.textContent = btn.dataset.trackTitle;
        trackNotesTextarea.value = btn.dataset.trackNotes || '';
        trackNotesModal.classList.add('open');
        trackNotesTextarea.focus();
    }

    function closeTrackNotesModal() {
        trackNotesModal.classList.remove('open');
        currentTrackNotesBtn = null;
    }

    document.getElementById('track-notes-modal-close').addEventListener('click', closeTrackNotesModal);
    document.getElementById('track-notes-cancel').addEventListener('click', closeTrackNotesModal);
    trackNotesModal.querySelector('.modal-backdrop').addEventListener('click', closeTrackNotesModal);

    document.getElementById('track-notes-save').addEventListener('click', async () => {
        if (!currentTrackNotesBtn) return;

        const trackId = currentTrackNotesBtn.dataset.trackId;
        const notes = trackNotesTextarea.value.trim();

        try {
            const response = await fetch(`/releases/${releaseId}/tracks/${trackId}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ notes: notes || null })
            });

            if (response.ok) {
                closeTrackNotesModal();
                // Update the button display
                currentTrackNotesBtn.dataset.trackNotes = notes;
                currentTrackNotesBtn.title = notes || 'Add notes';
                if (notes) {
                    currentTrackNotesBtn.textContent = 'Notes';
                    currentTrackNotesBtn.classList.remove('track-notes-add');
                    currentTrackNotesBtn.classList.add('track-notes-indicator');
                } else {
                    currentTrackNotesBtn.textContent = '+';
                    currentTrackNotesBtn.classList.remove('track-notes-indicator');
                    currentTrackNotesBtn.classList.add('track-notes-add');
                }
            }
        } catch (err) {
            console.error('Failed to save notes:', err);
        }
    });

    // Track notes button click handlers
    document.querySelectorAll('.track-notes-btn').forEach(btn => {
        btn.addEventListener('click', () => openTrackNotesModal(btn));
    });

    // Close track notes modal on Escape
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            if (trackNotesModal.classList.contains('open')) closeTrackNotesModal();
        }
    });

    // Column settings
    const columnSettingsModal = document.getElementById('column-settings-modal');
    const columnSettingsList = document.getElementById('column-settings-list');

    // Get current visible fields from data attribute
    const tracksSection = document.querySelector('.tracks-section');
    let visibleFields = tracksSection.dataset.visibleFields.split(',').filter(f => f);

    // Initialize checkboxes based on current visibility
    function initColumnSettings() {
        columnSettingsList.querySelectorAll('input[type="checkbox"]').forEach(cb => {
            const field = cb.dataset.field;
            if (!cb.disabled) {
                cb.checked = visibleFields.includes(field);
            }
        });
    }

    // Toggle column visibility
    function setColumnVisible(field, visible) {
        const colCells = document.querySelectorAll(`.col-${field}`);
        colCells.forEach(cell => {
            cell.classList.toggle('hidden', !visible);
        });
    }

    // Open column settings modal
    document.getElementById('btn-column-settings').addEventListener('click', () => {
        initColumnSettings();
        columnSettingsModal.classList.add('open');
    });

    // Close modal handlers
    function closeColumnSettingsModal() {
        columnSettingsModal.classList.remove('open');
    }

    document.getElementById('column-settings-close').addEventListener('click', closeColumnSettingsModal);
    document.getElementById('column-settings-cancel').addEventListener('click', closeColumnSettingsModal);
    columnSettingsModal.querySelector('.modal-backdrop').addEventListener('click', closeColumnSettingsModal);

    // Save column settings
    document.getElementById('column-settings-save').addEventListener('click', async () => {
        const newVisibleFields = [];
        columnSettingsList.querySelectorAll('input[type="checkbox"]').forEach(cb => {
            if (cb.checked) {
                newVisibleFields.push(cb.dataset.field);
            }
        });

        try {
            const response = await fetch('/releases/settings/visible-fields', {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ visible_fields: newVisibleFields })
            });

            if (response.ok) {
                const result = await response.json();
                visibleFields = result.visible_fields;

                // Update column visibility
                ['position', 'duration', 'bpm', 'key', 'energy', 'tags'].forEach(field => {
                    setColumnVisible(field, visibleFields.includes(field));
                });

                closeColumnSettingsModal();
            }
        } catch (err) {
            console.error('Failed to save settings:', err);
        }
    });

    // Close on Escape
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && columnSettingsModal.classList.contains('open')) {
            closeColumnSettingsModal();
        }
    });
})();
</script>

<!-- Global datalist for tag autocomplete -->
<datalist id="all-tags-list"></datalist>
<script>
(function() {
    // Populate tag datalist after page load
    fetch('/tags/').then(r => r.json()).then(data => {
        const datalist = document.getElementById('all-tags-list');
        datalist.innerHTML = data.tags.map(t => `<option value="${t.name}">`).join('');
    });
})();
</script>
{% endblock %}
