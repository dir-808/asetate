{% extends "base.html" %}

{% block title %}{{ release.display_artist }} - {{ release.display_title }} - Asetate{% endblock %}

{% block content %}
<div class="release-detail" data-release-id="{{ release.id }}">
    <a href="{{ url_for('releases.list_releases') }}" class="back-link">Back to collection</a>

    <header class="release-header">
        <div class="release-cover-large">
            {% if release.cover_art_url %}
            <img src="{{ release.cover_art_url }}" alt="{{ release.display_title }}">
            {% else %}
            <div class="cover-placeholder-large">
                <span>No Cover</span>
            </div>
            {% endif %}
        </div>
        <div class="release-info-large">
            <h1>{{ release.display_title }}</h1>
            <p class="release-artist-large">{{ release.display_artist }}</p>
            <div class="release-meta-large">
                {% if release.label %}<span>{{ release.label }}</span>{% endif %}
                {% if release.year %}<span>{{ release.year }}</span>{% endif %}
            </div>
            <div class="release-stats">
                <span>{{ stats.total }} tracks</span>
                <span class="stat-divider">•</span>
                <span class="text-success">{{ stats.playable }} playable</span>
                <span class="stat-divider">•</span>
                <span>{{ stats.has_bpm }} with BPM</span>
            </div>
            <div class="release-actions">
                <a href="{{ release.discogs_uri }}" target="_blank" rel="noopener" class="btn btn-secondary btn-sm">
                    View on Discogs
                </a>
                {% if release.discogs_edit_url %}
                <a href="{{ release.discogs_edit_url }}" target="_blank" rel="noopener" class="btn btn-secondary btn-sm">
                    Suggest Edit
                </a>
                {% endif %}
                <button class="btn btn-primary btn-sm" id="btn-add-to-crate">Add to Crate</button>
            </div>
            <div class="release-crates" id="release-crates">
                <!-- Crates will be loaded via JS -->
            </div>
        </div>
    </header>

    <section class="tracks-section">
        <div class="tracks-header">
            <h2>Tracklist</h2>
            <span class="save-indicator" id="save-indicator"></span>
        </div>

        {% if tracks %}
        <div class="tracks-table-wrapper">
            <table class="tracks-table">
                <thead>
                    <tr>
                        <th class="col-pos">Side</th>
                        <th class="col-title">Title</th>
                        <th class="col-duration">Length</th>
                        <th class="col-bpm">BPM</th>
                        <th class="col-key">Key</th>
                        <th class="col-energy">Energy</th>
                        <th class="col-playable">Playable</th>
                    </tr>
                </thead>
                <tbody>
                    {% for track in tracks %}
                    <tr class="track-row {% if track.is_playable %}track-playable{% endif %}"
                        data-track-id="{{ track.id }}">
                        <td class="col-pos">{{ track.display_position }}</td>
                        <td class="col-title">
                            <span class="track-title">{{ track.title }}</span>
                            {% if track.notes %}
                            <span class="track-notes-indicator" title="{{ track.notes }}">Notes</span>
                            {% endif %}
                        </td>
                        <td class="col-duration">{{ track.display_duration }}</td>
                        <td class="col-bpm">
                            <input
                                type="number"
                                class="track-input track-bpm"
                                value="{{ track.bpm or '' }}"
                                placeholder="—"
                                min="20"
                                max="300"
                                data-field="bpm"
                            >
                        </td>
                        <td class="col-key">
                            <input
                                type="text"
                                class="track-input track-key"
                                value="{{ track.camelot or track.musical_key or '' }}"
                                placeholder="—"
                                data-field="camelot"
                                list="camelot-keys"
                            >
                        </td>
                        <td class="col-energy">
                            <input
                                type="number"
                                class="track-input track-energy"
                                value="{{ track.energy or '' }}"
                                placeholder="—"
                                min="1"
                                max="10"
                                data-field="energy"
                            >
                        </td>
                        <td class="col-playable">
                            <label class="toggle">
                                <input
                                    type="checkbox"
                                    class="track-playable"
                                    {% if track.is_playable %}checked{% endif %}
                                    data-field="is_playable"
                                >
                                <span class="toggle-slider"></span>
                            </label>
                        </td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>

        <!-- Camelot key datalist for autocomplete -->
        <datalist id="camelot-keys">
            <option value="1A"><option value="1B">
            <option value="2A"><option value="2B">
            <option value="3A"><option value="3B">
            <option value="4A"><option value="4B">
            <option value="5A"><option value="5B">
            <option value="6A"><option value="6B">
            <option value="7A"><option value="7B">
            <option value="8A"><option value="8B">
            <option value="9A"><option value="9B">
            <option value="10A"><option value="10B">
            <option value="11A"><option value="11B">
            <option value="12A"><option value="12B">
        </datalist>

        {% else %}
        <p class="text-muted">No tracks found for this release.</p>
        {% endif %}
    </section>
</div>

<!-- Add to Crate Modal -->
<div class="modal" id="crate-modal">
    <div class="modal-backdrop"></div>
    <div class="modal-content">
        <div class="modal-header">
            <h2>Add to Crate</h2>
            <button class="modal-close" id="crate-modal-close">&times;</button>
        </div>
        <div class="crate-selector">
            <div id="crate-list" class="crate-select-list">
                <p class="text-muted">Loading crates...</p>
            </div>
            <div class="crate-selector-footer">
                <a href="{{ url_for('crates.list_crates') }}" class="text-secondary">Manage crates</a>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
(function() {
    const releaseId = document.querySelector('.release-detail').dataset.releaseId;
    const saveIndicator = document.getElementById('save-indicator');
    let saveTimeout = null;

    function showSaving() {
        saveIndicator.textContent = 'Saving...';
        saveIndicator.className = 'save-indicator saving';
    }

    function showSaved() {
        saveIndicator.textContent = 'Saved';
        saveIndicator.className = 'save-indicator saved';
        clearTimeout(saveTimeout);
        saveTimeout = setTimeout(() => {
            saveIndicator.textContent = '';
            saveIndicator.className = 'save-indicator';
        }, 2000);
    }

    function showError(message) {
        saveIndicator.textContent = message || 'Error saving';
        saveIndicator.className = 'save-indicator error';
    }

    async function updateTrack(trackId, field, value) {
        showSaving();

        const data = {};
        data[field] = value;

        try {
            const response = await fetch(`/releases/${releaseId}/tracks/${trackId}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });

            const result = await response.json();

            if (response.ok) {
                showSaved();

                // Update row styling for playable status
                if (field === 'is_playable') {
                    const row = document.querySelector(`tr[data-track-id="${trackId}"]`);
                    if (value) {
                        row.classList.add('track-playable');
                    } else {
                        row.classList.remove('track-playable');
                    }
                }
            } else {
                showError(result.error);
            }
        } catch (err) {
            showError('Network error');
            console.error('Failed to update track:', err);
        }
    }

    // Handle input changes with debouncing
    let debounceTimers = {};

    function handleInputChange(e) {
        const input = e.target;
        const row = input.closest('tr');
        const trackId = row.dataset.trackId;
        const field = input.dataset.field;
        let value = input.value;

        // For checkboxes, use checked state
        if (input.type === 'checkbox') {
            value = input.checked;
            updateTrack(trackId, field, value);
            return;
        }

        // Debounce text/number inputs
        clearTimeout(debounceTimers[trackId + field]);
        debounceTimers[trackId + field] = setTimeout(() => {
            // Convert empty strings to null
            if (value === '') value = null;
            updateTrack(trackId, field, value);
        }, 500);
    }

    // Attach listeners to all track inputs
    document.querySelectorAll('.track-input, .track-playable').forEach(input => {
        if (input.type === 'checkbox') {
            input.addEventListener('change', handleInputChange);
        } else {
            input.addEventListener('input', handleInputChange);
            // Also save on blur for immediate feedback
            input.addEventListener('blur', (e) => {
                clearTimeout(debounceTimers[e.target.closest('tr').dataset.trackId + e.target.dataset.field]);
                handleInputChange(e);
            });
        }
    });

    // Keyboard navigation between cells
    document.querySelectorAll('.track-input').forEach(input => {
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === 'Tab') {
                // Let browser handle Tab normally
                if (e.key === 'Enter') {
                    e.preventDefault();
                    // Move to next row, same column
                    const row = input.closest('tr');
                    const nextRow = row.nextElementSibling;
                    if (nextRow) {
                        const nextInput = nextRow.querySelector(`.${input.classList[1]}`);
                        if (nextInput) nextInput.focus();
                    }
                }
            }
        });
    });

    // Crate management
    const crateModal = document.getElementById('crate-modal');
    const crateList = document.getElementById('crate-list');
    const releaseCratesContainer = document.getElementById('release-crates');
    let allCrates = [];
    let releaseCrateIds = [];

    async function loadCrates() {
        try {
            const [cratesRes, releaseRes] = await Promise.all([
                fetch('/crates/api/list'),
                fetch(`/crates/api/for-release/${releaseId}`)
            ]);
            const cratesData = await cratesRes.json();
            const releaseData = await releaseRes.json();

            allCrates = cratesData.crates;
            releaseCrateIds = releaseData.crate_ids;

            updateReleaseCratesDisplay();
        } catch (err) {
            console.error('Failed to load crates:', err);
        }
    }

    function updateReleaseCratesDisplay() {
        const inCrates = allCrates.filter(c => releaseCrateIds.includes(c.id));
        if (inCrates.length > 0) {
            releaseCratesContainer.innerHTML = inCrates.map(c =>
                `<span class="crate-badge">${c.full_path}</span>`
            ).join('');
        } else {
            releaseCratesContainer.innerHTML = '<span class="text-muted">Not in any crate</span>';
        }
    }

    function renderCrateList() {
        if (allCrates.length === 0) {
            crateList.innerHTML = '<p class="text-muted">No crates yet. <a href="/crates/">Create one</a></p>';
            return;
        }

        crateList.innerHTML = allCrates.map(c => {
            const isIn = releaseCrateIds.includes(c.id);
            const indent = '&nbsp;&nbsp;'.repeat(c.depth);
            return `
                <label class="crate-select-item">
                    <input type="checkbox" data-crate-id="${c.id}" ${isIn ? 'checked' : ''}>
                    <span>${indent}${c.name}</span>
                </label>
            `;
        }).join('');

        // Add event listeners
        crateList.querySelectorAll('input[type="checkbox"]').forEach(cb => {
            cb.addEventListener('change', async (e) => {
                const crateId = parseInt(cb.dataset.crateId);
                const isChecked = cb.checked;

                try {
                    if (isChecked) {
                        await fetch(`/crates/${crateId}/releases`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ release_id: parseInt(releaseId) })
                        });
                        releaseCrateIds.push(crateId);
                    } else {
                        await fetch(`/crates/${crateId}/releases/${releaseId}`, {
                            method: 'DELETE'
                        });
                        releaseCrateIds = releaseCrateIds.filter(id => id !== crateId);
                    }
                    updateReleaseCratesDisplay();
                } catch (err) {
                    cb.checked = !isChecked; // Revert
                    alert('Failed to update crate');
                }
            });
        });
    }

    document.getElementById('btn-add-to-crate').addEventListener('click', () => {
        renderCrateList();
        crateModal.classList.add('open');
    });

    document.getElementById('crate-modal-close').addEventListener('click', () => {
        crateModal.classList.remove('open');
    });

    crateModal.querySelector('.modal-backdrop').addEventListener('click', () => {
        crateModal.classList.remove('open');
    });

    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && crateModal.classList.contains('open')) {
            crateModal.classList.remove('open');
        }
    });

    // Load crates on page load
    loadCrates();
})();
</script>
{% endblock %}
