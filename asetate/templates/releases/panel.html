{# Side panel partial for release details - loaded via AJAX #}
{% from "_icons.html" import emoji_icon, crate_icon %}
<div class="panel-release" data-release-id="{{ release.id }}">
    <!-- Discogs Card - clickable to open full page, with action buttons on right -->
    <div class="panel-discogs-card" id="panel-discogs-card" data-href="{{ url_for('releases.view_release', release_id=release.id) }}">
        <div class="panel-discogs-content">
            <div class="panel-cover">
                {% if release.cover_art_url %}
                <img src="{{ release.cover_art_url }}" alt="{{ release.display_title }}">
                {% else %}
                <div class="cover-placeholder-panel">
                    <span>No Cover</span>
                </div>
                {% endif %}
            </div>
            <div class="panel-info">
                <h2>{{ release.display_title }}</h2>
                <p class="panel-artist">{{ release.display_artist }}</p>
                <div class="panel-meta">
                    {% if release.label %}<span>{{ release.label }}</span>{% endif %}
                    {% if release.year %}<span>{{ release.year }}</span>{% endif %}
                </div>
                {% set avg_bpm = release.get_average_bpm() %}
                <div class="panel-stats">
                    <span class="panel-stat" title="Total tracks"><span class="stat-icon">â™«</span>{{ stats.total }}</span>
                    <span class="panel-stat text-success" title="Playable tracks"><span class="stat-icon">â–¶</span>{{ stats.playable }}</span>
                    {% if avg_bpm.value %}
                    <span class="panel-stat avg-bpm {% if avg_bpm.is_varied %}bpm-varied{% endif %}" title="Average BPM">{{ avg_bpm.display }}<span class="stat-label">bpm</span></span>
                    {% endif %}
                </div>
            </div>
        </div>
        <div class="panel-discogs-buttons">
            <a href="{{ release.discogs_uri }}" target="_blank" rel="noopener"
               class="panel-discogs-btn" title="View on Discogs" onclick="event.stopPropagation();">
                {{ emoji_icon('link', size=18) }}
            </a>
            {% if release.discogs_edit_url %}
            <a href="{{ release.discogs_edit_url }}" target="_blank" rel="noopener"
               class="panel-discogs-btn" title="Edit on Discogs" onclick="event.stopPropagation();">
                {{ emoji_icon('edit', size=18) }}
            </a>
            {% endif %}
            <button class="panel-discogs-btn" id="panel-btn-sync" title="Sync from Discogs" onclick="event.stopPropagation();">
                <span class="activity-led"></span>
                {{ emoji_icon('sync', size=18) }}
            </button>
        </div>
    </div>

    <!-- Release Notes - LCD style, sits below Discogs card -->
    <textarea class="panel-notes-textarea panel-notes-lcd" id="panel-release-notes" placeholder="Add notes...">{{ release.notes or '' }}</textarea>

    <!-- Actions + Crates - unified row -->
    <div class="panel-toolbar">
        <div class="panel-toolbar-actions">
            <div class="panel-crate-dropdown-wrapper">
                <button class="btn btn-primary btn-sm" id="panel-btn-add-to-crate">Crate â–¾</button>
                <div class="panel-crate-dropdown" id="panel-crate-dropdown" style="display: none;">
                    <div class="panel-crate-dropdown-list" id="panel-crate-dropdown-list">
                        <!-- Crates loaded via JS -->
                    </div>
                </div>
            </div>
            <button class="btn btn-secondary btn-sm" id="panel-btn-add-to-cue" title="Add to print cue">Print</button>
        </div>
        <div class="panel-toolbar-crates" id="panel-release-crates">
            <!-- Crates will be loaded via JS -->
        </div>
    </div>

    <!-- Tracks Section - LCD style continuation -->
    <section class="panel-tracks">

        {% if tracks %}
        <div class="panel-tracks-list" id="panel-tracks-list">
            {% for track in tracks %}
            <div class="panel-track-row {% if not track.is_playable %}track-dimmed{% endif %}"
                 data-track-id="{{ track.id }}">
                <!-- Left column: Toggle only -->
                <div class="panel-track-left">
                    <label class="toggle toggle--mini" title="Playable">
                        <input type="checkbox" class="panel-track-playable"
                               {% if track.is_playable %}checked{% endif %}
                               data-field="is_playable">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <!-- Right content: Position + Title, Duration, and fields -->
                <div class="panel-track-right">
                    <div class="panel-track-main">
                        <span class="panel-track-pos">{{ track.display_position }}</span>
                        <span class="panel-track-title">{{ track.title }}</span>
                        <span class="panel-track-duration">{{ track.display_duration }}</span>
                    </div>
                    <div class="panel-track-fields">
                        <input type="number" class="panel-input panel-input--editable panel-bpm"
                               value="{{ track.bpm or '' }}" placeholder="BPM"
                               min="20" max="300" data-field="bpm" title="BPM">
                        <input type="text" class="panel-input panel-input--editable panel-key"
                               value="{{ track.camelot or track.musical_key or '' }}"
                               placeholder="Key" data-field="camelot" list="panel-camelot-keys" title="Key">
                        <div class="energy-bar energy-bar--sm" data-field="energy" data-value="{{ track.energy or 3 }}" title="Energy: {{ track.energy or 3 }}/5">
                            <div class="energy-segment" data-level="1"></div>
                            <div class="energy-segment" data-level="2"></div>
                            <div class="energy-segment" data-level="3"></div>
                            <div class="energy-segment" data-level="4"></div>
                            <div class="energy-segment" data-level="5"></div>
                        </div>
                        <div class="panel-track-actions">
                            <button class="panel-notes-btn {% if track.notes %}has-notes{% endif %}"
                                    data-track-id="{{ track.id }}"
                                    data-track-notes="{{ track.notes or '' }}"
                                    title="{% if track.notes %}Edit notes{% else %}Add notes{% endif %}">
                                {{ emoji_icon('notes', size=12) }}
                            </button>
                            <div class="panel-track-tags" data-track-id="{{ track.id }}">
                                {% for tag in track.tags %}
                                <span class="tag-badge-sm" data-tag-id="{{ tag.id }}" style="--tag-color: {{ tag.color or '#E07A5F' }}">{{ tag.name }}</span>
                                {% endfor %}
                                <button class="panel-tag-add-btn" title="Add tag">
                                    {{ emoji_icon('tag', size=12) }}
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            {% endfor %}
        </div>

        <datalist id="panel-camelot-keys">
            <option value="1A"><option value="1B">
            <option value="2A"><option value="2B">
            <option value="3A"><option value="3B">
            <option value="4A"><option value="4B">
            <option value="5A"><option value="5B">
            <option value="6A"><option value="6B">
            <option value="7A"><option value="7B">
            <option value="8A"><option value="8B">
            <option value="9A"><option value="9B">
            <option value="10A"><option value="10B">
            <option value="11A"><option value="11B">
            <option value="12A"><option value="12B">
        </datalist>
        {% else %}
        <p class="text-muted" style="padding: var(--space-md);">No tracks found.</p>
        {% endif %}
    </section>
</div>

<!-- Track Notes Modal (inline for panel) -->
<div class="panel-notes-modal" id="panel-track-notes-modal" style="display: none;">
    <div class="panel-notes-modal-content">
        <div class="panel-notes-modal-header">
            <h4>Track Notes</h4>
            <button class="modal-close" id="panel-notes-modal-close">&times;</button>
        </div>
        <textarea id="panel-track-notes-textarea" rows="4" placeholder="Add notes about this track..."></textarea>
        <div class="panel-notes-modal-actions">
            <button class="btn btn-secondary btn-sm" id="panel-notes-cancel">Cancel</button>
            <button class="btn btn-primary btn-sm" id="panel-notes-save">Save</button>
        </div>
    </div>
</div>

<!-- Tag datalist for autocomplete -->
<datalist id="panel-all-tags"></datalist>

<!-- NOTE: All panel styles now in style.css SIDE PANEL section -->

<script>
(function() {
    const releaseId = {{ release.id }};
    let allTags = [];

    async function updateTrack(trackId, field, value) {
        const data = {};
        data[field] = value;

        try {
            const response = await fetch(`/releases/${releaseId}/tracks/${trackId}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });

            if (response.ok) {
                if (field === 'is_playable') {
                    const row = document.querySelector(`.panel-track-row[data-track-id="${trackId}"]`);
                    row.classList.toggle('track-dimmed', !value);
                    updatePanelStats();
                }
                if (field === 'bpm') {
                    updatePanelStats();
                }
            }
        } catch (err) {
            console.error('Failed to update track:', err);
        }
    }

    // Update stats after changes
    function updatePanelStats() {
        const rows = document.querySelectorAll('.panel-track-row');
        let playableCount = 0;
        let totalBpm = 0;
        let bpmCount = 0;

        rows.forEach(row => {
            const isPlayable = !row.classList.contains('track-dimmed');
            if (isPlayable) {
                playableCount++;
                const bpmInput = row.querySelector('.panel-bpm');
                if (bpmInput && bpmInput.value) {
                    totalBpm += parseInt(bpmInput.value);
                    bpmCount++;
                }
            }
        });

        // Update playable count (preserve the icon)
        const statsEl = document.querySelector('.panel-stats .text-success');
        if (statsEl) {
            const icon = statsEl.querySelector('.stat-icon');
            const iconHtml = icon ? icon.outerHTML : '<span class="stat-icon">â–¶</span>';
            statsEl.innerHTML = `${iconHtml}${playableCount}`;
        }

        // Update avg BPM (preserve the label)
        const avgBpmEl = document.querySelector('.panel-stats .avg-bpm');
        if (avgBpmEl && bpmCount > 0) {
            avgBpmEl.innerHTML = `${Math.round(totalBpm / bpmCount)}<span class="stat-label">bpm</span>`;
        }
    }

    // Debounced input handler
    let debounceTimers = {};

    document.querySelectorAll('.panel-input').forEach(input => {
        input.addEventListener('input', (e) => {
            const row = input.closest('.panel-track-row');
            const trackId = row.dataset.trackId;
            const field = input.dataset.field;

            clearTimeout(debounceTimers[trackId + field]);
            debounceTimers[trackId + field] = setTimeout(() => {
                let value = input.value;
                if (value === '') value = null;
                updateTrack(trackId, field, value);
            }, 500);
        });
    });

    // Checkbox handler - immediate visual update
    document.querySelectorAll('.panel-track-playable').forEach(cb => {
        cb.addEventListener('change', (e) => {
            const row = cb.closest('.panel-track-row');
            const trackId = row.dataset.trackId;
            const isPlayable = cb.checked;

            // Immediate visual update before API call
            row.classList.toggle('track-dimmed', !isPlayable);

            updateTrack(trackId, 'is_playable', isPlayable);
        });
    });

    // Energy bar click and drag handler - supports dragging outside the bar
    // Use global state to handle drag across multiple panel loads
    if (!window._panelEnergyDrag) {
        window._panelEnergyDrag = {
            isDragging: false,
            currentBar: null,
            currentTrackId: null,
            currentReleaseId: null,
            updateTrackFn: null
        };

        // Document-level listeners - only add once
        document.addEventListener('mousemove', (e) => {
            const state = window._panelEnergyDrag;
            if (state.isDragging && state.currentBar) {
                const rect = state.currentBar.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const segmentWidth = rect.width / 5;
                let level = Math.ceil(x / segmentWidth);
                level = Math.max(1, Math.min(5, level));
                state.currentBar.setAttribute('data-value', level);
            }
        });

        document.addEventListener('mouseup', (e) => {
            const state = window._panelEnergyDrag;
            if (state.isDragging && state.currentTrackId && state.currentBar && state.updateTrackFn) {
                const level = parseInt(state.currentBar.getAttribute('data-value'));
                state.updateTrackFn(state.currentTrackId, 'energy', level);
            }
            state.isDragging = false;
            state.currentBar = null;
            state.currentTrackId = null;
            state.currentReleaseId = null;
        });
    }

    // Update the global state with current updateTrack function
    window._panelEnergyDrag.updateTrackFn = updateTrack;

    // Attach mousedown to energy bars
    document.querySelectorAll('.energy-bar').forEach(bar => {
        bar.addEventListener('mousedown', (e) => {
            const state = window._panelEnergyDrag;
            state.isDragging = true;
            state.currentBar = bar;
            state.currentReleaseId = releaseId;
            const row = bar.closest('.panel-track-row');
            state.currentTrackId = row.dataset.trackId;

            // Calculate and set initial level
            const rect = bar.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const segmentWidth = rect.width / 5;
            let level = Math.ceil(x / segmentWidth);
            level = Math.max(1, Math.min(5, level));
            bar.setAttribute('data-value', level);
            e.preventDefault();
        });
    });

    // Track Notes Modal
    const notesModal = document.getElementById('panel-track-notes-modal');
    const notesTextarea = document.getElementById('panel-track-notes-textarea');
    let currentNotesTrackId = null;

    document.querySelectorAll('.panel-notes-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            currentNotesTrackId = btn.dataset.trackId;
            notesTextarea.value = btn.dataset.trackNotes || '';
            notesModal.style.display = 'flex';
            notesTextarea.focus();
        });
    });

    document.getElementById('panel-notes-modal-close')?.addEventListener('click', () => {
        notesModal.style.display = 'none';
    });

    document.getElementById('panel-notes-cancel')?.addEventListener('click', () => {
        notesModal.style.display = 'none';
    });

    document.getElementById('panel-notes-save')?.addEventListener('click', async () => {
        if (!currentNotesTrackId) return;

        const notes = notesTextarea.value.trim();

        try {
            const response = await fetch(`/releases/${releaseId}/tracks/${currentNotesTrackId}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ notes: notes || null })
            });

            if (response.ok) {
                notesModal.style.display = 'none';
                // Update button
                const btn = document.querySelector(`.panel-notes-btn[data-track-id="${currentNotesTrackId}"]`);
                if (btn) {
                    btn.dataset.trackNotes = notes;
                    if (notes) {
                        btn.classList.add('has-notes');
                    } else {
                        btn.classList.remove('has-notes');
                    }
                }
            }
        } catch (err) {
            console.error('Failed to save notes:', err);
        }
    });

    // Load all tags for autocomplete
    async function loadAllTags() {
        try {
            const response = await fetch('/tags/');
            const data = await response.json();
            allTags = data.tags;
            // Populate datalist
            const datalist = document.getElementById('panel-all-tags');
            datalist.innerHTML = allTags.map(t => `<option value="${t.name}">`).join('');
        } catch (err) {
            console.error('Failed to load tags:', err);
        }
    }
    loadAllTags();

    // Tag management
    async function addTagToTrack(trackId, tagName) {
        try {
            const response = await fetch(`/tags/track/${trackId}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: tagName.trim().toLowerCase() })
            });
            const result = await response.json();
            if (response.ok) {
                // Add new tag to allTags immediately if it doesn't exist
                if (!allTags.some(t => t.id === result.tag.id)) {
                    allTags.push(result.tag);
                    // Update datalist
                    const datalist = document.getElementById('panel-all-tags');
                    datalist.innerHTML = allTags.map(t => `<option value="${t.name}">`).join('');
                }
                return result.tag;
            }
            // Silently ignore 409 (tag already exists) - not an error for the user
            if (response.status === 409) {
                return null;
            }
            return null;
        } catch (err) {
            console.error('Failed to add tag:', err);
            return null;
        }
    }

    async function removeTagFromTrack(trackId, tagId) {
        try {
            await fetch(`/tags/track/${trackId}/${tagId}`, { method: 'DELETE' });
        } catch (err) {
            console.error('Failed to remove tag:', err);
        }
    }

    // Tag add button handler
    document.querySelectorAll('.panel-tag-add-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const container = btn.closest('.panel-track-tags');
            const trackId = container.dataset.trackId;

            // Check if input already exists
            if (container.querySelector('.panel-tag-input')) return;

            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'panel-tag-input';
            input.placeholder = 'tag';
            input.setAttribute('list', 'panel-all-tags');
            container.insertBefore(input, btn);
            input.focus();

            async function submitTag() {
                const value = input.value.trim();
                if (value) {
                    const tag = await addTagToTrack(trackId, value);
                    if (tag) {
                        const tagEl = document.createElement('span');
                        tagEl.className = 'tag-badge-sm';
                        tagEl.dataset.tagId = tag.id;
                        tagEl.style.setProperty('--tag-color', tag.color || '#E07A5F');
                        tagEl.textContent = tag.name;
                        container.insertBefore(tagEl, input);
                    }
                }
                input.remove();
            }

            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    submitTag();
                } else if (e.key === 'Escape') {
                    input.remove();
                }
            });

            // Apply tag on selecting from dropdown
            input.addEventListener('change', () => {
                if (input.value.trim()) {
                    submitTag();
                }
            });

            input.addEventListener('blur', () => {
                setTimeout(() => input.remove(), 150);
            });
        });
    });

    // Inline Release Notes - auto-save with debounce
    const releaseNotesTextarea = document.getElementById('panel-release-notes');
    let notesDebounceTimer = null;

    async function saveReleaseNotes() {
        const notes = releaseNotesTextarea.value.trim();

        try {
            await fetch(`/releases/${releaseId}/notes`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ notes: notes || null })
            });
        } catch (err) {
            console.error('Failed to save notes:', err);
        }
    }

    releaseNotesTextarea.addEventListener('input', () => {
        clearTimeout(notesDebounceTimer);
        notesDebounceTimer = setTimeout(saveReleaseNotes, 800);
    });

    releaseNotesTextarea.addEventListener('blur', () => {
        clearTimeout(notesDebounceTimer);
        if (releaseNotesTextarea.value !== releaseNotesTextarea.defaultValue) {
            saveReleaseNotes();
        }
    });

    // Crate dropdown with multi-select
    let allCrates = [];
    let releaseCrateIds = [];
    const crateBtn = document.getElementById('panel-btn-add-to-crate');
    const crateDropdown = document.getElementById('panel-crate-dropdown');
    const crateDropdownList = document.getElementById('panel-crate-dropdown-list');
    const cratesContainer = document.getElementById('panel-release-crates');

    async function loadCrates() {
        try {
            const [cratesRes, releaseRes] = await Promise.all([
                fetch('/crates/api/list'),
                fetch(`/crates/api/for-release/${releaseId}`)
            ]);
            const cratesData = await cratesRes.json();
            const releaseData = await releaseRes.json();

            allCrates = cratesData.crates;
            releaseCrateIds = releaseData.crate_ids;

            updateCratesDisplay();
            updateCrateDropdown();
        } catch (err) {
            console.error('Failed to load crates:', err);
        }
    }

    // Use centralized icon system (loaded from icons.js)
    // Size is font-size in pixels - uses Noto Emoji font
    // âš ï¸ KEEP IN SYNC with static/js/icons.js EMOJI_CHARS - this is a fallback for edge cases
    const EMOJI_CHARS_FALLBACK = {
        folder: 'ðŸ“', vinyl: 'ðŸ’¿', headphones: 'ðŸŽ§', music: 'ðŸŽµ',
        speaker: 'ðŸ”Š', disco: 'ðŸª©', wave: 'ðŸŒŠ', fire: 'ðŸ”¥',
        bolt: 'âš¡', star: 'â­', heart: 'â¤', diamond: 'ðŸ’Ž',
        crown: 'ðŸ‘‘', sun: 'ðŸŒž', moon: 'ðŸŒ™', globe: 'ðŸŒ',
        clock: 'ðŸ•°', skull: 'ðŸ’€', box: 'ðŸ“¦', check: 'âœ”', plus: 'âž•'
    };

    // Helper to convert hexcode to emoji character
    function hexcodeToEmoji(hexcode) {
        try {
            const codepoints = hexcode.split('-').map(cp => parseInt(cp, 16));
            return String.fromCodePoint(...codepoints);
        } catch {
            return EMOJI_CHARS_FALLBACK.folder;
        }
    }

    // Check if value looks like a hexcode
    function isHexcode(value) {
        return /^[0-9A-F]+(-[0-9A-F]+)*$/i.test(value);
    }

    const renderCrateIcon = window.AsetateIcons?.renderCrateIcon || ((crate, size = 16) => {
        const colorStyle = crate.color_hex ? `color: ${crate.color_hex};` : '';
        let char = EMOJI_CHARS_FALLBACK.folder;

        if (crate.icon) {
            let iconValue = '';
            if (crate.icon.startsWith('emoji:') || crate.icon.startsWith('pixel:')) {
                iconValue = crate.icon.slice(6);
            }

            if (iconValue) {
                if (isHexcode(iconValue)) {
                    // New format: emoji:HEXCODE (e.g., "emoji:1F4BF")
                    char = hexcodeToEmoji(iconValue);
                } else {
                    // Legacy format: emoji:iconname (e.g., "emoji:vinyl")
                    char = EMOJI_CHARS_FALLBACK[iconValue] || EMOJI_CHARS_FALLBACK.folder;
                }
            }
        }

        return `<span class="emoji-icon" style="font-size: ${size}px;${colorStyle}">${char}</span>`;
    });

    function updateCratesDisplay() {
        const inCrates = allCrates.filter(c => releaseCrateIds.includes(c.id));
        if (inCrates.length > 0) {
            cratesContainer.style.display = '';
            cratesContainer.innerHTML = inCrates.map(c => {
                const bgStyle = c.color_hex ? `background-color: ${c.color_hex}20; border-color: ${c.color_hex}40;` : '';
                return `<a href="/crates/${c.id}" class="crate-badge-panel" style="${bgStyle}" onclick="event.stopPropagation();">
                    ${renderCrateIcon(c, 16)}
                    <span class="crate-badge-name">${c.name}</span>
                </a>`;
            }).join('');
        } else {
            cratesContainer.style.display = 'none';
            cratesContainer.innerHTML = '';
        }
    }

    function updateCrateDropdown() {
        crateDropdownList.innerHTML = allCrates.map(c => {
            const isSelected = releaseCrateIds.includes(c.id);
            return `<label class="panel-crate-item ${isSelected ? 'selected' : ''}" data-crate-id="${c.id}">
                <input type="checkbox" ${isSelected ? 'checked' : ''}>
                ${renderCrateIcon(c, 14)}
                <span class="panel-crate-item-name">${c.name}</span>
            </label>`;
        }).join('');

        // Add event listeners to checkboxes
        crateDropdownList.querySelectorAll('.panel-crate-item input[type="checkbox"]').forEach(cb => {
            cb.addEventListener('change', async (e) => {
                const item = cb.closest('.panel-crate-item');
                const crateId = parseInt(item.dataset.crateId);

                if (cb.checked) {
                    // Add to crate
                    try {
                        const res = await fetch(`/crates/${crateId}/releases`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ release_id: releaseId })
                        });
                        if (res.ok) {
                            releaseCrateIds.push(crateId);
                            item.classList.add('selected');
                        } else {
                            cb.checked = false;
                        }
                    } catch (err) {
                        cb.checked = false;
                    }
                } else {
                    // Remove from crate
                    try {
                        const res = await fetch(`/crates/${crateId}/releases/${releaseId}`, {
                            method: 'DELETE'
                        });
                        if (res.ok) {
                            releaseCrateIds = releaseCrateIds.filter(id => id !== crateId);
                            item.classList.remove('selected');
                        } else {
                            cb.checked = true;
                        }
                    } catch (err) {
                        cb.checked = true;
                    }
                }
                updateCratesDisplay();
            });
        });
    }

    // Toggle dropdown
    crateBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const isOpen = crateDropdown.style.display !== 'none';
        crateDropdown.style.display = isOpen ? 'none' : 'block';
    });

    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
        if (!crateDropdown.contains(e.target) && e.target !== crateBtn) {
            crateDropdown.style.display = 'none';
        }
    });

    loadCrates();

    // Sync release button (icon-only version)
    const syncBtn = document.getElementById('panel-btn-sync');
    if (syncBtn) {
        syncBtn.addEventListener('click', async () => {
            syncBtn.disabled = true;
            syncBtn.classList.add('is-loading');

            try {
                const response = await fetch(`/sync/release/${releaseId}`, {
                    method: 'POST'
                });

                if (response.ok) {
                    // Reload the panel to show updated data
                    window.location.reload();
                } else {
                    syncBtn.classList.remove('is-loading');
                    syncBtn.classList.add('has-error');
                    setTimeout(() => {
                        syncBtn.classList.remove('has-error');
                        syncBtn.disabled = false;
                    }, 2000);
                }
            } catch (err) {
                syncBtn.classList.remove('is-loading');
                syncBtn.classList.add('has-error');
                setTimeout(() => {
                    syncBtn.classList.remove('has-error');
                    syncBtn.disabled = false;
                }, 2000);
            }
        });
    }

    // Discogs card click to open full page
    const discogsCard = document.getElementById('panel-discogs-card');
    if (discogsCard) {
        discogsCard.addEventListener('click', () => {
            window.location.href = discogsCard.dataset.href;
        });
    }

    // Add to Print Cue
    const addCueBtn = document.getElementById('panel-btn-add-to-cue');
    if (addCueBtn) {
        addCueBtn.addEventListener('click', () => {
            const trackRows = document.querySelectorAll('.panel-track-row');
            const tracks = [];
            trackRows.forEach(row => {
                const trackId = parseInt(row.dataset.trackId);
                const title = row.querySelector('.panel-track-title')?.textContent || '';
                const position = row.querySelector('.panel-track-pos')?.textContent || '';
                tracks.push({
                    track_id: trackId,
                    release_id: releaseId,
                    artist: '{{ release.display_artist | e }}',
                    title: `${position} ${title}`.trim(),
                });
            });

            let exportCue = JSON.parse(localStorage.getItem('asetate_export_cue') || '[]');
            let addedCount = 0;
            tracks.forEach(track => {
                if (!exportCue.some(q => q.track_id === track.track_id)) {
                    exportCue.push(track);
                    addedCount++;
                }
            });
            localStorage.setItem('asetate_export_cue', JSON.stringify(exportCue));

            if (addedCount > 0) {
                addCueBtn.textContent = `+${addedCount}`;
                setTimeout(() => { addCueBtn.textContent = 'Print cue'; }, 1500);
            } else {
                addCueBtn.textContent = 'In cue';
                setTimeout(() => { addCueBtn.textContent = 'Print cue'; }, 1500);
            }
        });
    }
})();
</script>
