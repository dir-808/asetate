{% extends "base.html" %}
{% from "_icons.html" import emoji_icon, crate_icon %}

{% block title %}Crates - Asetate{% endblock %}

{% block content %}
<div class="crates-page-layout">
    <div class="crates-main" id="crates-main">
        <header class="crates-header">
            <div>
                <h1>Crates</h1>
                <p class="text-secondary">{{ total_crates }} crate{% if total_crates != 1 %}s{% endif %}</p>
            </div>
            <button class="btn btn-primary" id="btn-new-crate">New Crate</button>
        </header>

        {% if crate_tree %}
        <div class="crates-grid">
            {% macro render_crate(node, depth=0) %}
            <a href="{{ url_for('crates.view_crate', crate_id=node.crate.id) }}"
               class="crate-box {% if depth > 0 %}sub-crate{% endif %}"
               data-crate-id="{{ node.crate.id }}"
               style="{% if node.crate.color_hex %}--crate-accent: {{ node.crate.color_hex }}{% endif %}">
                <!-- Crate lid (opens on hover) -->
                <div class="crate-lid">
                    <div class="crate-lid-inner">
                        <span class="crate-lid-label">{{ node.crate.name[:12] }}{% if node.crate.name|length > 12 %}...{% endif %}</span>
                    </div>
                </div>
                <!-- Crate body -->
                <div class="crate-body">
                    <div class="crate-icon-container">
                        {{ crate_icon(node.crate, size=32) }}
                    </div>
                    <div class="crate-info">
                        <span class="crate-name">{{ node.crate.name }}</span>
                        <span class="crate-stats">{{ node.release_count }} releases</span>
                    </div>
                    <!-- Action buttons (on hover) -->
                    <div class="crate-hover-actions">
                        <button class="crate-action-btn crate-edit-btn"
                                data-crate-id="{{ node.crate.id }}"
                                title="Edit">‚úé</button>
                        <button class="crate-action-btn crate-subcrate-btn"
                                data-crate-id="{{ node.crate.id }}"
                                data-crate-name="{{ node.crate.name }}"
                                title="Add sub-crate">+</button>
                    </div>
                </div>
                <!-- Crate slats (visual only) -->
                <div class="crate-slat crate-slat-1"></div>
                <div class="crate-slat crate-slat-2"></div>
            </a>
            {% if node.children %}
            {% for child in node.children %}
            {{ render_crate(child, depth + 1) }}
            {% endfor %}
            {% endif %}
            {% endmacro %}

            {% for node in crate_tree %}
            {{ render_crate(node) }}
            {% endfor %}
        </div>
        {% else %}
        <div class="empty-state">
            <h2>No crates yet</h2>
            <p>Create crates to organize your releases and tracks by genre, mood, or however you like.</p>
            <button class="btn btn-primary" id="btn-new-crate-empty">Create Your First Crate</button>
        </div>
        {% endif %}
    </div>

    <!-- Crate Edit Sidebar -->
    <aside class="crate-panel" id="crate-panel">
        <div class="crate-panel-header">
            <h3>Edit Crate</h3>
            <button class="panel-close" id="crate-panel-close">&times;</button>
        </div>
        <div class="crate-panel-content" id="crate-panel-content">
            <!-- Content loaded via JS -->
        </div>
    </aside>
</div>

<!-- New Crate Modal -->
<div class="modal" id="new-crate-modal">
    <div class="modal-backdrop"></div>
    <div class="modal-content">
        <div class="modal-header">
            <h2 id="modal-title">New Crate</h2>
            <button class="modal-close" id="modal-close">&times;</button>
        </div>
        <form id="new-crate-form">
            <div class="form-group">
                <label for="crate-name">Name</label>
                <input type="text" id="crate-name" name="name" placeholder="e.g., Deep House" required autofocus>
            </div>
            <div class="form-group">
                <label for="crate-description">Description (optional)</label>
                <input type="text" id="crate-description" name="description" placeholder="e.g., Late night vibes">
            </div>

            <!-- Emoji Icon Picker -->
            <div class="form-group">
                <label>Icon</label>
                <div class="icon-picker-container">
                    <div class="icon-input-row">
                        <div class="icon-preview-box" id="icon-preview">
                            <span class="emoji-icon emoji-icon--2xl" id="icon-preview-emoji">üìÅ</span>
                        </div>
                        <input type="text"
                               id="crate-icon-search"
                               class="icon-search-input"
                               placeholder="Search icons...">
                        <button type="button" class="btn btn-secondary btn-sm" id="clear-icon">Reset</button>
                    </div>
                    <div class="emoji-icon-grid" id="icon-grid">
                        <!-- Emoji icons loaded via JS -->
                    </div>
                </div>
                <input type="hidden" id="crate-icon" name="icon" value="">
            </div>

            <!-- Color Picker -->
            <div class="form-group">
                <label>Color</label>
                <div class="color-picker" id="color-picker">
                    <button type="button" class="color-option selected" data-color="" style="background: var(--color-none)" title="None"></button>
                    {% for color in crate_colors %}
                    <button type="button" class="color-option" data-color="{{ color.id }}" style="background-color: {{ color.hex }}" title="{{ color.name }}"></button>
                    {% endfor %}
                    <div class="color-custom" title="Custom color">
                        <label class="color-custom-label" for="custom-color">
                            <span class="color-custom-icon">üé®</span>
                            <input type="color" id="custom-color" value="#337EA9">
                        </label>
                    </div>
                </div>
                <input type="hidden" id="crate-color" name="color" value="">
            </div>

            <input type="hidden" id="crate-parent-id" name="parent_id" value="">
            <div class="form-group" id="parent-display" style="display: none;">
                <label>Inside</label>
                <span id="parent-name" class="parent-badge"></span>
            </div>
            <div class="modal-actions">
                <button type="button" class="btn btn-secondary" id="btn-cancel">Cancel</button>
                <button type="submit" class="btn btn-primary">Create Crate</button>
            </div>
        </form>
    </div>
</div>
<!-- NOTE: Crate list page styles now in style.css CRATES section -->
{% endblock %}

{% block scripts %}
<script type="module">
import { getIconName } from '/static/js/icons.js';

const modal = document.getElementById('new-crate-modal');
const modalTitle = document.getElementById('modal-title');
const form = document.getElementById('new-crate-form');
const nameInput = document.getElementById('crate-name');
const parentIdInput = document.getElementById('crate-parent-id');
const parentDisplay = document.getElementById('parent-display');
const parentName = document.getElementById('parent-name');
const iconInput = document.getElementById('crate-icon');
const colorInput = document.getElementById('crate-color');
const iconGrid = document.getElementById('icon-grid');
const clearIconBtn = document.getElementById('clear-icon');
const cratePanel = document.getElementById('crate-panel');
const cratePanelContent = document.getElementById('crate-panel-content');
const cratesMain = document.getElementById('crates-main');
const iconPreviewEmoji = document.getElementById('icon-preview-emoji');
const iconSearchInput = document.getElementById('crate-icon-search');

const DEFAULT_EMOJI = 'üìÅ';
const DEFAULT_HEXCODE = '1F4C1';
let currentSelectedHexcode = null;
let cachedEmoji = [];

// Get current color from color picker
function getCurrentColor() {
    // Check custom color first
    const customColor = document.getElementById('custom-color');
    if (colorInput.value && colorInput.value.startsWith('#')) {
        return colorInput.value;
    }
    // Check selected color option
    const selectedOption = document.querySelector('#color-picker .color-option.selected');
    if (selectedOption && selectedOption.dataset.color) {
        // Get the background color from the button style
        return selectedOption.style.backgroundColor || null;
    }
    return null;
}

// Update emoji preview with color
function updateEmojiPreview(emoji, hexcode) {
    iconPreviewEmoji.textContent = emoji || DEFAULT_EMOJI;
    currentSelectedHexcode = hexcode || DEFAULT_HEXCODE;
    applyColorToPreview();
}

// Apply current color to preview
function applyColorToPreview() {
    const color = getCurrentColor();
    iconPreviewEmoji.style.color = color || '';
}

// Apply color to all emoji in grid
function applyColorToGrid() {
    const color = getCurrentColor();
    iconGrid.querySelectorAll('.emoji-icon').forEach(icon => {
        icon.style.color = color || '';
    });
}

// Fetch emoji from API
async function fetchEmoji(query = '') {
    try {
        const url = `/crates/api/emoji?q=${encodeURIComponent(query)}&limit=60`;
        const response = await fetch(url);
        const data = await response.json();
        return data.emoji || [];
    } catch (err) {
        console.error('Failed to fetch emoji:', err);
        return [];
    }
}

// Render emoji grid
function renderEmojiGrid(emojiList, selectedHexcode = null) {
    const color = getCurrentColor();
    iconGrid.innerHTML = '';
    emojiList.forEach(e => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'emoji-icon-grid-item' + (selectedHexcode === e.hexcode ? ' selected' : '');
        btn.dataset.hexcode = e.hexcode;
        btn.title = `${e.name} (${e.keywords.slice(0, 3).join(', ')})`;
        const colorStyle = color ? ` style="color: ${color};"` : '';
        btn.innerHTML = `<span class="emoji-icon emoji-icon--lg"${colorStyle}>${e.emoji}</span>`;
        btn.addEventListener('click', () => selectEmoji(e.emoji, e.hexcode));
        iconGrid.appendChild(btn);
    });
}

// Select emoji handler
function selectEmoji(emoji, hexcode) {
    iconInput.value = `emoji:${hexcode}`;
    updateEmojiPreview(emoji, hexcode);
    iconGrid.querySelectorAll('.emoji-icon-grid-item').forEach(btn => {
        btn.classList.toggle('selected', btn.dataset.hexcode === hexcode);
    });
}

// Initialize emoji grid
async function initEmojiGrid() {
    if (cachedEmoji.length === 0) {
        cachedEmoji = await fetchEmoji('');
    }
    renderEmojiGrid(cachedEmoji, currentSelectedHexcode);
}

// Search with debounce
let searchTimeout = null;
iconSearchInput.addEventListener('input', () => {
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(async () => {
        const query = iconSearchInput.value.trim();
        if (query) {
            const results = await fetchEmoji(query);
            renderEmojiGrid(results, currentSelectedHexcode);
        } else {
            renderEmojiGrid(cachedEmoji, currentSelectedHexcode);
        }
    }, 200);
});

clearIconBtn.addEventListener('click', async () => {
    iconInput.value = '';
    iconSearchInput.value = '';
    updateEmojiPreview(DEFAULT_EMOJI, DEFAULT_HEXCODE);
    renderEmojiGrid(cachedEmoji, null);
});

// Color picker - apply color to all emoji when changed
document.querySelectorAll('#color-picker .color-option').forEach(btn => {
    btn.addEventListener('click', () => {
        document.querySelectorAll('#color-picker .color-option').forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
        colorInput.value = btn.dataset.color;
        applyColorToPreview();
        applyColorToGrid();
    });
});

const customColorInput = document.getElementById('custom-color');
customColorInput.addEventListener('input', () => {
    document.querySelectorAll('#color-picker .color-option').forEach(b => b.classList.remove('selected'));
    colorInput.value = customColorInput.value;
    applyColorToPreview();
    applyColorToGrid();
});

function openModal(parentId = null, parentCrateName = null) {
    if (parentId) {
        modalTitle.textContent = 'New Sub-Crate';
        parentIdInput.value = parentId;
        parentName.textContent = parentCrateName;
        parentDisplay.style.display = 'block';
    } else {
        modalTitle.textContent = 'New Crate';
        parentIdInput.value = '';
        parentDisplay.style.display = 'none';
    }
    modal.classList.add('open');
    nameInput.focus();
    initEmojiGrid();
}

function closeModal() {
    modal.classList.remove('open');
    form.reset();
    iconInput.value = '';
    iconSearchInput.value = '';
    currentSelectedHexcode = null;
    updateEmojiPreview(DEFAULT_EMOJI, DEFAULT_HEXCODE);
    document.querySelectorAll('#color-picker .color-option').forEach((b, i) => b.classList.toggle('selected', i === 0));
    colorInput.value = '';
    cachedEmoji = []; // Clear cache so next open refetches
}

document.getElementById('btn-new-crate')?.addEventListener('click', () => openModal());
document.getElementById('btn-new-crate-empty')?.addEventListener('click', () => openModal());

document.querySelectorAll('.crate-subcrate-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        openModal(btn.dataset.crateId, btn.dataset.crateName);
    });
});

document.getElementById('modal-close').addEventListener('click', closeModal);
document.getElementById('btn-cancel').addEventListener('click', closeModal);
document.querySelector('.modal-backdrop').addEventListener('click', closeModal);

document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        if (modal.classList.contains('open')) closeModal();
        if (cratePanel.classList.contains('open')) closePanel();
    }
});

form.addEventListener('submit', async (e) => {
    e.preventDefault();

    const data = {
        name: nameInput.value.trim(),
        description: document.getElementById('crate-description').value.trim(),
        parent_id: parentIdInput.value ? parseInt(parentIdInput.value) : null,
        icon: iconInput.value || null,
        color: colorInput.value || null,
    };

    try {
        const response = await fetch('/crates/', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data),
        });

        const result = await response.json();

        if (response.ok) {
            window.location.href = '/crates/' + result.crate.id;
        } else {
            alert(result.error || 'Failed to create crate');
        }
    } catch (err) {
        alert('Error creating crate: ' + err.message);
    }
});

// Crate edit panel
function openPanel(crateId) {
    cratePanel.classList.add('open');
    document.body.classList.add('crate-panel-open');
    loadCrateForEdit(crateId);
}

function closePanel() {
    cratePanel.classList.remove('open');
    document.body.classList.remove('crate-panel-open');
}

document.getElementById('crate-panel-close').addEventListener('click', closePanel);

async function loadCrateForEdit(crateId) {
    try {
        const response = await fetch(`/crates/api/${crateId}`);
        const data = await response.json();

        if (response.ok) {
            renderPanelForm(data.crate);
        } else {
            cratePanelContent.innerHTML = '<p class="text-muted">Failed to load crate</p>';
        }
    } catch (err) {
        cratePanelContent.innerHTML = '<p class="text-muted">Error loading crate</p>';
    }
}

async function renderPanelForm(crate) {
    // Extract hexcode from crate.icon (format: "emoji:HEXCODE")
    let currentHexcode = DEFAULT_HEXCODE;
    let currentEmoji = DEFAULT_EMOJI;
    if (crate.icon && crate.icon.startsWith('emoji:')) {
        currentHexcode = crate.icon.slice(6);
        // We'll get the emoji character from the API
    }

    cratePanelContent.innerHTML = `
        <form id="panel-edit-form">
            <div class="panel-form-group">
                <label>Name</label>
                <input type="text" id="panel-name" value="${crate.name || ''}" required>
            </div>
            <div class="panel-form-group">
                <label>Description</label>
                <input type="text" id="panel-description" value="${crate.description || ''}" placeholder="Optional description">
            </div>
            <div class="panel-form-group">
                <label>Icon</label>
                <div class="icon-picker-container panel-icon-picker">
                    <div class="icon-input-row">
                        <div class="icon-preview-box" id="panel-icon-preview">
                            <span class="emoji-icon" id="panel-icon-preview-emoji"></span>
                        </div>
                        <input type="text" id="panel-icon-search" class="icon-search-input" placeholder="Search icons...">
                    </div>
                    <div class="emoji-icon-grid" id="panel-icon-grid"></div>
                </div>
                <input type="hidden" id="panel-icon" value="${crate.icon || ''}">
            </div>
            <div class="panel-form-group">
                <label>Color</label>
                <div class="color-picker" id="panel-color-picker">
                    <button type="button" class="color-option ${!crate.color_hex ? 'selected' : ''}" data-color="" style="background: var(--color-none)"></button>
                    {% for color in crate_colors %}
                    <button type="button" class="color-option" data-color="{{ color.id }}" style="background-color: {{ color.hex }}"></button>
                    {% endfor %}
                </div>
                <input type="hidden" id="panel-color" value="${crate.color || ''}">
            </div>
            <div class="panel-actions">
                <button type="button" class="btn btn-secondary" id="panel-cancel">Cancel</button>
                <button type="submit" class="btn btn-primary">Save</button>
            </div>
        </form>
        <div class="panel-danger-zone">
            <h4>Danger Zone</h4>
            <button class="btn btn-danger" id="panel-delete">Delete Crate</button>
        </div>
    `;

    // Setup panel form handlers
    const panelForm = document.getElementById('panel-edit-form');
    const panelIconPreviewEmoji = document.getElementById('panel-icon-preview-emoji');
    const panelIconInput = document.getElementById('panel-icon');
    const panelIconGrid = document.getElementById('panel-icon-grid');
    const panelColorInput = document.getElementById('panel-color');
    const panelIconSearch = document.getElementById('panel-icon-search');
    let panelCachedEmoji = [];
    let panelSelectedHexcode = currentHexcode;

    // Get panel current color
    function getPanelCurrentColor() {
        const selectedOption = document.querySelector('#panel-color-picker .color-option.selected');
        if (selectedOption && selectedOption.style.backgroundColor && selectedOption.style.backgroundColor !== 'var(--border)') {
            return selectedOption.style.backgroundColor;
        }
        return crate.color_hex || null;
    }

    function applyPanelColorToPreview() {
        const color = getPanelCurrentColor();
        panelIconPreviewEmoji.style.color = color || '';
    }

    function applyPanelColorToGrid() {
        const color = getPanelCurrentColor();
        panelIconGrid.querySelectorAll('.emoji-icon').forEach(icon => {
            icon.style.color = color || '';
        });
    }

    function updatePanelPreview(emoji, hexcode) {
        panelIconPreviewEmoji.textContent = emoji || DEFAULT_EMOJI;
        panelSelectedHexcode = hexcode || DEFAULT_HEXCODE;
        applyPanelColorToPreview();
    }

    function selectPanelEmoji(emoji, hexcode) {
        panelIconInput.value = `emoji:${hexcode}`;
        updatePanelPreview(emoji, hexcode);
        panelIconGrid.querySelectorAll('.emoji-icon-grid-item').forEach(btn => {
            btn.classList.toggle('selected', btn.dataset.hexcode === hexcode);
        });
    }

    function renderPanelEmojiGrid(emojiList, selectedHexcode = null) {
        const color = getPanelCurrentColor();
        panelIconGrid.innerHTML = '';
        emojiList.forEach(e => {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'emoji-icon-grid-item' + (selectedHexcode === e.hexcode ? ' selected' : '');
            btn.dataset.hexcode = e.hexcode;
            btn.title = `${e.name} (${e.keywords.slice(0, 3).join(', ')})`;
            const colorStyle = color ? ` style="color: ${color};"` : '';
            btn.innerHTML = `<span class="emoji-icon emoji-icon--lg"${colorStyle}>${e.emoji}</span>`;
            btn.addEventListener('click', () => selectPanelEmoji(e.emoji, e.hexcode));
            panelIconGrid.appendChild(btn);

            // Set initial preview if this is the current icon
            if (e.hexcode === currentHexcode) {
                currentEmoji = e.emoji;
            }
        });
    }

    // Load emoji and initialize
    panelCachedEmoji = await fetchEmoji('');
    renderPanelEmojiGrid(panelCachedEmoji, panelSelectedHexcode);

    // Find current emoji character from loaded list
    const currentEmojiObj = panelCachedEmoji.find(e => e.hexcode === currentHexcode);
    updatePanelPreview(currentEmojiObj?.emoji || DEFAULT_EMOJI, currentHexcode);

    // Panel icon search
    let panelSearchTimeout = null;
    panelIconSearch.addEventListener('input', () => {
        clearTimeout(panelSearchTimeout);
        panelSearchTimeout = setTimeout(async () => {
            const query = panelIconSearch.value.trim();
            if (query) {
                const results = await fetchEmoji(query);
                renderPanelEmojiGrid(results, panelSelectedHexcode);
            } else {
                renderPanelEmojiGrid(panelCachedEmoji, panelSelectedHexcode);
            }
        }, 200);
    });

    document.querySelectorAll('#panel-color-picker .color-option').forEach(btn => {
        if (btn.dataset.color === (crate.color || '')) {
            btn.classList.add('selected');
        }
        btn.addEventListener('click', () => {
            document.querySelectorAll('#panel-color-picker .color-option').forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');
            panelColorInput.value = btn.dataset.color;
            applyPanelColorToPreview();
            applyPanelColorToGrid();
        });
    });

    document.getElementById('panel-cancel').addEventListener('click', closePanel);

    panelForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const updateData = {
            name: document.getElementById('panel-name').value.trim(),
            description: document.getElementById('panel-description').value.trim(),
            icon: panelIconInput.value || null,
            color: panelColorInput.value || null,
        };

        try {
            const response = await fetch(`/crates/${crate.id}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(updateData),
            });

            if (response.ok) {
                window.location.reload();
            } else {
                const result = await response.json();
                alert(result.error || 'Failed to update crate');
            }
        } catch (err) {
            alert('Error updating crate');
        }
    });

    document.getElementById('panel-delete').addEventListener('click', async () => {
        if (!confirm('Are you sure you want to delete this crate? This cannot be undone.')) return;

        try {
            const response = await fetch(`/crates/${crate.id}`, { method: 'DELETE' });
            if (response.ok) {
                window.location.reload();
            } else {
                const result = await response.json();
                alert(result.error || 'Failed to delete crate');
            }
        } catch (err) {
            alert('Error deleting crate');
        }
    });
}

// Edit button click handlers - stop navigation
document.querySelectorAll('.crate-edit-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        openPanel(btn.dataset.crateId);
    });
});
</script>
{% endblock %}
