{% extends "base.html" %}

{% block title %}Sync - Asetate{% endblock %}

{% block content %}
<div class="sync-page">
    <header class="page-header">
        <h1>Discogs Sync</h1>
        <p class="text-secondary">Keep your collection up to date</p>
    </header>

    <div class="sync-card card" id="sync-card">
        <div class="sync-status">
            <span class="status-indicator" id="status-indicator"></span>
            <span class="status-text" id="status-text">{{ sync_status.message }}</span>
        </div>

        <div class="sync-progress" id="sync-progress" style="display: {% if sync_status.status == 'running' %}block{% else %}none{% endif %};">
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill" style="width: {{ sync_status.progress_percent or 0 }}%"></div>
            </div>
            <div class="progress-details">
                <span class="progress-text" id="progress-text">
                    {{ sync_status.processed or 0 }} / {{ sync_status.total or 0 }} releases
                </span>
                <span class="progress-percent" id="progress-percent">{{ sync_status.progress_percent|round(1) if sync_status.progress_percent else 0 }}%</span>
            </div>
            <!-- Current release being processed -->
            <div class="current-release" id="current-release">
                <span class="current-release-label">Now importing:</span>
                <span class="current-release-text" id="current-release-text">
                    {% if sync_status.current_release_artist and sync_status.current_release_title %}
                        {{ sync_status.current_release_artist }} - {{ sync_status.current_release_title }}
                    {% else %}
                        Starting...
                    {% endif %}
                </span>
            </div>
            <!-- Live stats during sync -->
            <div class="sync-live-stats" id="sync-live-stats">
                <span class="live-stat"><span class="live-stat-value" id="live-added">{{ sync_status.added or 0 }}</span> added</span>
                <span class="live-stat-sep">·</span>
                <span class="live-stat"><span class="live-stat-value" id="live-updated">{{ sync_status.updated or 0 }}</span> updated</span>
            </div>
        </div>

        <div class="sync-stats" id="sync-stats" style="display: {% if sync_status.status == 'completed' %}grid{% else %}none{% endif %};">
            <div class="sync-stat">
                <span class="sync-stat-value" id="stat-added">{{ sync_status.added or 0 }}</span>
                <span class="sync-stat-label">Added</span>
            </div>
            <div class="sync-stat">
                <span class="sync-stat-value" id="stat-updated">{{ sync_status.updated or 0 }}</span>
                <span class="sync-stat-label">Updated</span>
            </div>
            <div class="sync-stat">
                <span class="sync-stat-value" id="stat-removed">{{ sync_status.removed or 0 }}</span>
                <span class="sync-stat-label">Removed</span>
            </div>
        </div>

        {% if sync_status.last_error %}
        <div class="sync-error" id="sync-error">
            <div class="sync-error-header">
                <span class="error-icon">⚠</span>
                <span class="error-title">Sync Error</span>
            </div>
            <p class="error-message" id="error-message">{{ sync_status.last_error }}</p>
            <p class="error-hint">You can try resuming the sync or start a fresh sync.</p>
        </div>
        {% else %}
        <div class="sync-error" id="sync-error" style="display: none;">
            <div class="sync-error-header">
                <span class="error-icon">⚠</span>
                <span class="error-title">Sync Error</span>
            </div>
            <p class="error-message" id="error-message"></p>
            <p class="error-hint">You can try resuming the sync or start a fresh sync.</p>
        </div>
        {% endif %}

        <div class="sync-actions">
            <button class="btn btn-primary" id="btn-sync"
                {% if not sync_status.can_sync %}disabled{% endif %}>
                <span class="btn-spinner" id="btn-sync-spinner"></span>
                <span class="btn-text" id="btn-sync-text">Pull from Discogs</span>
            </button>
            <button class="btn btn-secondary" id="btn-resume"
                style="display: {% if sync_status.can_resume %}inline-flex{% else %}none{% endif %};">
                <span class="btn-spinner"></span><span class="btn-text">Resume Sync</span>
            </button>
            <button class="btn btn-secondary" id="btn-cancel"
                style="display: {% if sync_status.status == 'running' %}inline-flex{% else %}none{% endif %};">
                <span class="btn-spinner"></span><span class="btn-text">Pause</span>
            </button>
        </div>
    </div>

    <section class="sync-info card">
        <h2>How it works</h2>
        <ul class="info-list">
            <li>Asetate pulls your entire collection from Discogs</li>
            <li>New releases are added, existing ones are updated</li>
            <li>Releases you've removed from Discogs are flagged for review</li>
            <li>Your DJ metadata (BPM, key, crates) is always preserved</li>
            <li>Discogs limits requests to 60/minute - large collections may take a while</li>
        </ul>
    </section>

    {% if current_user.is_seller_mode %}
    <!-- Inventory Sync Section (Seller Mode) -->
    <div class="inventory-sync-section">
        <header class="section-header">
            <h2>Inventory Sync</h2>
            <span class="badge badge-seller">Seller Mode</span>
        </header>

        <div class="sync-card card" id="inventory-sync-card">
            <div class="sync-status">
                <span class="status-indicator" id="inv-status-indicator"></span>
                <span class="status-text" id="inv-status-text">Ready to sync inventory</span>
            </div>

            <div class="inventory-stats" id="inventory-stats">
                <div class="sync-stat">
                    <span class="sync-stat-value" id="inv-stat-synced">0</span>
                    <span class="sync-stat-label">Items Listed</span>
                </div>
                <div class="sync-stat">
                    <span class="sync-stat-value" id="inv-stat-last-sync">Never</span>
                    <span class="sync-stat-label">Last Sync</span>
                </div>
            </div>

            <div class="sync-actions">
                <button class="btn btn-primary" id="btn-inventory-sync">
                    <span class="btn-spinner"></span><span class="btn-text">Sync Inventory</span>
                </button>
            </div>

            <p class="text-secondary inventory-note">
                Pulls condition, sleeve condition, price, and location for items listed on your Discogs inventory.
                Update these values in Discogs, then sync here to keep your local data current.
            </p>
        </div>

        <!-- Inventory Notifications (sold/removed items) -->
        <div class="inventory-notifications card" id="inventory-notifications" style="display: none;">
            <div class="notifications-header">
                <h3>Items Sold / Removed</h3>
                <button class="btn btn-secondary btn-sm" id="btn-dismiss-all">Dismiss All</button>
            </div>
            <p class="text-secondary">These items are no longer in your Discogs inventory.</p>
            <div class="notification-list" id="notification-list">
                <!-- Notifications will be loaded here -->
            </div>
        </div>

        <div class="sync-info card">
            <h3>Inventory vs Collection</h3>
            <ul class="info-list">
                <li><strong>Collection sync</strong> pulls all records you own from Discogs</li>
                <li><strong>Inventory sync</strong> only pulls data for items listed for sale</li>
                <li>To update condition/price, edit the listing on Discogs then sync</li>
                <li>You can also sync individual releases from the release detail page</li>
            </ul>
        </div>
    </div>
    {% endif %}
</div>
<!-- NOTE: Sync page styles (progress, errors, notifications) now in style.css SYNC PAGE section -->
{% endblock %}

{% block scripts %}
<script>
(function() {
    const statusText = document.getElementById('status-text');
    const statusIndicator = document.getElementById('status-indicator');
    const progressSection = document.getElementById('sync-progress');
    const progressFill = document.getElementById('progress-fill');
    const progressText = document.getElementById('progress-text');
    const progressPercent = document.getElementById('progress-percent');
    const currentReleaseText = document.getElementById('current-release-text');
    const liveAdded = document.getElementById('live-added');
    const liveUpdated = document.getElementById('live-updated');
    const statsSection = document.getElementById('sync-stats');
    const errorSection = document.getElementById('sync-error');
    const errorMessage = document.getElementById('error-message');
    const btnSync = document.getElementById('btn-sync');
    const btnSyncText = document.getElementById('btn-sync-text');
    const btnResume = document.getElementById('btn-resume');
    const btnCancel = document.getElementById('btn-cancel');

    let pollInterval = null;

    function updateUI(status) {
        statusText.textContent = status.message;
        statusIndicator.className = 'status-indicator status-' + status.status;

        // Progress bar and details
        if (status.status === 'running') {
            progressSection.style.display = 'block';
            progressFill.style.width = status.progress_percent + '%';
            progressText.textContent = status.processed + ' / ' + status.total + ' releases';
            progressPercent.textContent = status.progress_percent.toFixed(1) + '%';

            // Current release being imported
            if (status.current_release_artist && status.current_release_title) {
                currentReleaseText.textContent = status.current_release_artist + ' - ' + status.current_release_title;
            } else if (status.processed === 0) {
                currentReleaseText.textContent = 'Connecting to Discogs...';
            }

            // Live stats
            liveAdded.textContent = status.added || 0;
            liveUpdated.textContent = status.updated || 0;

            statsSection.style.display = 'none';

            // Update button state
            btnSync.classList.add('is-loading');
            btnSyncText.textContent = 'Syncing...';
        } else {
            progressSection.style.display = 'none';
            btnSync.classList.remove('is-loading');
            btnSyncText.textContent = 'Pull from Discogs';
        }

        // Stats (show when completed)
        if (status.status === 'completed') {
            statsSection.style.display = 'grid';
            document.getElementById('stat-added').textContent = status.added;
            document.getElementById('stat-updated').textContent = status.updated;
            document.getElementById('stat-removed').textContent = status.removed;
        }

        // Error display
        if (status.last_error && (status.status === 'failed' || status.status === 'paused')) {
            errorSection.style.display = 'block';
            errorMessage.textContent = status.last_error;
        } else {
            errorSection.style.display = 'none';
        }

        // Buttons
        btnSync.disabled = !status.can_sync;
        btnResume.style.display = status.can_resume ? 'inline-flex' : 'none';
        btnCancel.style.display = status.status === 'running' ? 'inline-flex' : 'none';

        // Start/stop polling based on status
        if (status.status === 'running' && !pollInterval) {
            startPolling();
        } else if (status.status !== 'running' && pollInterval) {
            stopPolling();
        }
    }

    function startPolling() {
        if (pollInterval) return;
        pollInterval = setInterval(fetchStatus, 1500); // Poll every 1.5s for smoother updates
    }

    function stopPolling() {
        if (pollInterval) {
            clearInterval(pollInterval);
            pollInterval = null;
        }
    }

    async function fetchStatus() {
        try {
            const response = await fetch('/sync/status');
            if (!response.ok) {
                const result = await response.json();
                showError(result.error || 'Failed to fetch status');
                return;
            }
            const status = await response.json();
            updateUI(status);
        } catch (err) {
            console.error('Failed to fetch status:', err);
        }
    }

    function showError(message) {
        errorSection.style.display = 'block';
        errorMessage.textContent = message;
    }

    async function startSync() {
        btnSync.disabled = true;
        btnSync.classList.add('is-loading');
        btnSyncText.textContent = 'Starting...';
        errorSection.style.display = 'none';

        try {
            const response = await fetch('/sync/start', { method: 'POST' });
            const result = await response.json();

            if (response.ok) {
                startPolling();
                fetchStatus();
            } else {
                showError(result.error || 'Failed to start sync');
                btnSync.disabled = false;
                btnSync.classList.remove('is-loading');
                btnSyncText.textContent = 'Pull from Discogs';
            }
        } catch (err) {
            showError('Failed to start sync: ' + err.message);
            btnSync.disabled = false;
            btnSync.classList.remove('is-loading');
            btnSyncText.textContent = 'Pull from Discogs';
        }
    }

    async function resumeSync() {
        btnResume.disabled = true;
        errorSection.style.display = 'none';

        try {
            const response = await fetch('/sync/resume', { method: 'POST' });
            const result = await response.json();

            if (response.ok) {
                startPolling();
                fetchStatus();
            } else {
                showError(result.error || 'Failed to resume sync');
            }
        } catch (err) {
            showError('Failed to resume sync: ' + err.message);
        }

        btnResume.disabled = false;
    }

    async function cancelSync() {
        btnCancel.disabled = true;

        try {
            const response = await fetch('/sync/cancel', { method: 'POST' });
            const result = await response.json();

            if (response.ok) {
                fetchStatus();
            } else {
                showError(result.error || 'Failed to pause sync');
            }
        } catch (err) {
            showError('Failed to pause sync: ' + err.message);
        }

        btnCancel.disabled = false;
    }

    // Event listeners
    btnSync.addEventListener('click', startSync);
    btnResume.addEventListener('click', resumeSync);
    btnCancel.addEventListener('click', cancelSync);

    // Start polling if sync is running
    {% if sync_status.status == 'running' %}
    startPolling();
    {% endif %}
})();

{% if current_user.is_seller_mode %}
// Inventory Sync functionality
(function() {
    const invStatusText = document.getElementById('inv-status-text');
    const invStatusIndicator = document.getElementById('inv-status-indicator');
    const invStatSynced = document.getElementById('inv-stat-synced');
    const invStatLastSync = document.getElementById('inv-stat-last-sync');
    const btnInventorySync = document.getElementById('btn-inventory-sync');
    const notificationsSection = document.getElementById('inventory-notifications');
    const notificationList = document.getElementById('notification-list');
    const btnDismissAll = document.getElementById('btn-dismiss-all');

    let invPollInterval = null;

    function formatDate(isoString) {
        if (!isoString) return 'Never';
        const date = new Date(isoString);
        return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
    }

    function updateInventoryUI(status) {
        invStatSynced.textContent = status.items_synced || 0;
        invStatLastSync.textContent = formatDate(status.last_sync);
        const btnText = btnInventorySync.querySelector('.btn-text');

        if (status.is_running) {
            invStatusIndicator.className = 'status-indicator status-running';
            invStatusText.textContent = status.message || 'Syncing...';
            btnInventorySync.disabled = true;
            btnInventorySync.classList.add('is-loading');
            if (btnText) btnText.textContent = 'Syncing...';
        } else if (status.status === 'completed') {
            invStatusIndicator.className = 'status-indicator status-completed';
            invStatusText.textContent = status.message || 'Sync complete';
            btnInventorySync.disabled = false;
            btnInventorySync.classList.remove('is-loading');
            if (btnText) btnText.textContent = 'Sync Inventory';
            // Refresh notifications after sync completes
            fetchNotifications();
        } else if (status.status === 'failed') {
            invStatusIndicator.className = 'status-indicator status-failed';
            invStatusText.textContent = status.message || 'Sync failed';
            btnInventorySync.disabled = false;
            btnInventorySync.classList.remove('is-loading');
            if (btnText) btnText.textContent = 'Sync Inventory';
        } else {
            invStatusIndicator.className = 'status-indicator';
            invStatusText.textContent = 'Ready to sync inventory';
            btnInventorySync.disabled = false;
            btnInventorySync.classList.remove('is-loading');
            if (btnText) btnText.textContent = 'Sync Inventory';
        }

        // Start/stop polling
        if (status.is_running && !invPollInterval) {
            startInventoryPolling();
        } else if (!status.is_running && invPollInterval) {
            stopInventoryPolling();
        }
    }

    function startInventoryPolling() {
        if (invPollInterval) return;
        invPollInterval = setInterval(fetchInventoryStatus, 2000);
    }

    function stopInventoryPolling() {
        if (invPollInterval) {
            clearInterval(invPollInterval);
            invPollInterval = null;
        }
    }

    async function fetchInventoryStatus() {
        try {
            const response = await fetch('/sync/inventory/status');
            const status = await response.json();
            updateInventoryUI(status);
        } catch (err) {
            console.error('Failed to fetch inventory status:', err);
        }
    }

    async function startInventorySync() {
        const btnText = btnInventorySync.querySelector('.btn-text');
        btnInventorySync.disabled = true;
        btnInventorySync.classList.add('is-loading');
        if (btnText) btnText.textContent = 'Starting...';

        try {
            const response = await fetch('/sync/inventory/start', { method: 'POST' });
            const result = await response.json();

            if (response.ok) {
                startInventoryPolling();
                fetchInventoryStatus();
            } else {
                alert(result.error || 'Failed to start inventory sync');
                btnInventorySync.disabled = false;
                btnInventorySync.classList.remove('is-loading');
                if (btnText) btnText.textContent = 'Sync Inventory';
            }
        } catch (err) {
            alert('Failed to start inventory sync: ' + err.message);
            btnInventorySync.disabled = false;
            btnInventorySync.classList.remove('is-loading');
            if (btnText) btnText.textContent = 'Sync Inventory';
        }
    }

    // Notifications handling
    async function fetchNotifications() {
        try {
            const response = await fetch('/sync/inventory/notifications');
            const data = await response.json();
            renderNotifications(data.notifications || []);
        } catch (err) {
            console.error('Failed to fetch notifications:', err);
        }
    }

    function renderNotifications(notifications) {
        if (notifications.length === 0) {
            notificationsSection.style.display = 'none';
            return;
        }

        notificationsSection.style.display = 'block';
        notificationList.innerHTML = notifications.map(n => `
            <div class="notification-item" data-id="${n.id}">
                <div class="notification-content">
                    <span class="notification-badge ${n.status === 'sold' ? 'badge-sold' : 'badge-removed'}">
                        ${n.status === 'sold' ? 'SOLD' : 'REMOVED'}
                    </span>
                    <div class="notification-details">
                        <strong>${n.artist} - ${n.title}</strong>
                        <span class="text-secondary">${n.condition || ''} ${n.price ? '· ' + n.price : ''}</span>
                    </div>
                </div>
                <div class="notification-actions">
                    ${n.release_id ? `<a href="/releases/${n.release_id}" class="btn btn-secondary btn-sm">View</a>` : ''}
                    <button class="btn btn-secondary btn-sm btn-dismiss" data-id="${n.id}">Dismiss</button>
                </div>
            </div>
        `).join('');

        // Add dismiss handlers
        notificationList.querySelectorAll('.btn-dismiss').forEach(btn => {
            btn.addEventListener('click', () => dismissNotification(btn.dataset.id));
        });
    }

    async function dismissNotification(id) {
        try {
            const response = await fetch(`/sync/inventory/notifications/${id}/dismiss`, { method: 'POST' });
            if (response.ok) {
                const item = notificationList.querySelector(`[data-id="${id}"]`);
                if (item) item.remove();
                // Hide section if no more notifications
                if (notificationList.children.length === 0) {
                    notificationsSection.style.display = 'none';
                }
            }
        } catch (err) {
            console.error('Failed to dismiss notification:', err);
        }
    }

    async function dismissAllNotifications() {
        try {
            const response = await fetch('/sync/inventory/notifications/dismiss-all', { method: 'POST' });
            if (response.ok) {
                notificationList.innerHTML = '';
                notificationsSection.style.display = 'none';
            }
        } catch (err) {
            console.error('Failed to dismiss all notifications:', err);
        }
    }

    btnInventorySync.addEventListener('click', startInventorySync);
    btnDismissAll.addEventListener('click', dismissAllNotifications);

    // Fetch initial status and notifications
    fetchInventoryStatus();
    fetchNotifications();
})();
{% endif %}
</script>
{% endblock %}
